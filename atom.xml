<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[CatChen]]></title>
  <subtitle><![CDATA[我的王国，我一定会让你永垂不朽的]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://catlittlechen.com/"/>
  <updated>2017-02-20T13:14:33.000Z</updated>
  <id>http://catlittlechen.com/</id>
  
  <author>
    <name><![CDATA[Chan Cat]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[向2016致敬]]></title>
    <link href="http://catlittlechen.com/2017/01/25/%E5%90%912016%E8%87%B4%E6%95%AC/"/>
    <id>http://catlittlechen.com/2017/01/25/向2016致敬/</id>
    <published>2017-01-25T10:26:51.000Z</published>
    <updated>2017-02-20T13:14:33.000Z</updated>
    <content type="html"><![CDATA[<p>  2016年的我，你好，我是2017年的你。拖了很久，我才开始写这一封信给你，来告诉你，这一年的故事。先给你的2016年打一个分吧，87分，满分100分。</p>
<p>  2016年，在历经3年的努力下，你终于将自己多年的积蓄给父母买了一个房子，过年回家的时候，看到父母忙忙碌碌地整理房子，心情十分复杂。十几年来，当第一次懂事的时候，你就知道父母一直希望拥有这么一个属于自己的房子，只是一直没有能力。感谢2016年的你，在外包和工作等压力下，完成了这个心愿，过去3年，至少这件心愿，你完成了。不过，2016年的你，已经把所有的积蓄都花完了，苦了2017年的我了。你还记得你曾经答应嘻嘻给她在广州一个家么？我知道你一直都还记得，只是说，你已经尽力了。算了，那就让2017年的我好好努力吧。</p>
<p>  说到赚钱这一方面，2016年的你，很感谢你守住了另外一份承诺。没有在你身边的大环境的情况下，你做类似夺宝之类的产品。虽然2016年的你也没有推出个人作品，不管是CleverKid还是Say，就等2017年的我来完成吧。我知道努力坚持自己是有多难，感谢你坚持下来了。2017年的我也会好好坚持本心的。</p>
<p>  你是一个喜欢数学的理科生，但是这一年里面的工作其实大部分都和数学的相关性不大，其实你也没能够发挥出自己的特长。这也和你现在所在的工作岗位有关系吧。不过没关系，自己好好学习吧。现在大数据和人工智能这两方面都是比较热门的，也是十分适合你的工作，希望你可以好好珍惜。</p>
<p>  2017年的我，比起你而言，确实是长大了。我知道，也许选择比努力更加重要，你创造的多少价值，才能得到多少报酬。因此，希望我们可以创造自己的价值。想想2016年的年初，你还在抱怨年终太少之类的话，现在想想自己还是太幼稚了，你啊，确实是没有创造足够的价值，对吧？没事，我们这种人就是天生的骄傲型，相信天赋，过去努力积累的实例和未来的自己。纵使我们徘徊在现实和梦想之间，我们也会去看看梦想的世界，如果就这么屈服于现实，怎么知道世界的美好呢？</p>
<p>  不过，2016年的时候，你还是有几点是做得不够好的。首先，你发脾气了，虽然发脾气不是一件什么大不了的事情，但是事实上，在某些时候你不应该发脾气，比如对待嘻嘻的时候。人嘛，往往会宽容那些不熟的人，却无法容忍自己人的错误。这点希望以后可以改改。第二点不好的地方，话说，你学习swift做ios也好，机器学习也罢，要学习深一些，你现在两门的基础都没有打好，2016年反而觉得有点浪费了。后端没深入学习，反而学了两个兴趣方面，现在3个方面都没有好的发展。这样子不是很好。2017年的时候要好好选择一种，然后制定计划，好好学习。第三点，2016年，你从游戏转到了广告，恭喜你，先走出了一个温床，进入了另外一个温床~~告诉你哦，你还是得好好努力的。</p>
<p>  2016年的我，我知道你丢失了很多美好，我会在2017年，帮你找回来的。我相信你的骄傲，会有一天可以看到你的美好笑容和幸福。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>  2016年的我，你好，我是2017年的你。拖了很久，我才开始写这一封信给你，来告诉你，这一年的故事。先给你的2016年打一个分吧，87分，满分100分。</p>
<p>  2016年，在历经3年的努力下，你终于将自己多年的积蓄给父母买了一个房子，过年回家的时候，看到父母]]>
    </summary>
    
      <category term="生活" scheme="http://catlittlechen.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="活着" scheme="http://catlittlechen.com/categories/%E6%B4%BB%E7%9D%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[elasticsearch系列笔记(六)  索引]]></title>
    <link href="http://catlittlechen.com/2016/08/21/es6/"/>
    <id>http://catlittlechen.com/2016/08/21/es6/</id>
    <published>2016-08-21T12:37:01.000Z</published>
    <updated>2017-02-20T13:27:45.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u521B_u5EFA_u7D22_u5F15"><a href="#u521B_u5EFA_u7D22_u5F15" class="headerlink" title="创建索引"></a>创建索引</h4><pre><code>PUT /my_index
{
    &quot;settings&quot; {}
    &quot;mappings&quot;: {
        &quot;type_one&quot;:{},
        &quot;type_two&quot;:{},
    }
}
</code></pre><h4 id="u5220_u9664_u7D22_u5F15"><a href="#u5220_u9664_u7D22_u5F15" class="headerlink" title="删除索引"></a>删除索引</h4><pre><code>DELETE /my_index
</code></pre><h4 id="settings_3A"><a href="#settings_3A" class="headerlink" title="settings:"></a>settings:</h4><pre><code>number_of_shards    主索引的个数
number_of_replicas 复制分片的个数
</code></pre><p>分析器,这个很重要，合理的使用分析器，可以让你的es拥有合理的性能</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u521B_u5EFA_u7D22_u5F15"><a href="#u521B_u5EFA_u7D22_u5F15" class="headerlink" title="创建索引"></a>创建索引</h4><pre><code>PUT /my_index
{
]]>
    </summary>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/tags/elasticsearch/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/categories/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[elasticsearch系列笔记(五) 结构化查询]]></title>
    <link href="http://catlittlechen.com/2016/08/12/es5/"/>
    <id>http://catlittlechen.com/2016/08/12/es5/</id>
    <published>2016-08-12T13:16:59.000Z</published>
    <updated>2017-02-20T13:32:40.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u7ED3_u6784_u5316_u67E5_u8BE2Query_DSL"><a href="#u7ED3_u6784_u5316_u67E5_u8BE2Query_DSL" class="headerlink" title="结构化查询Query DSL"></a>结构化查询Query DSL</h4><pre><code>GET /_search
    {
        &quot;query&quot;: {
            QUERY_NAME: {
                FIELD_NAME: {
                    ARGUMENT: VALUE,
                    ARGUMENT: VALUE,
                }
            }
        }
    }
</code></pre><h4 id="u8FC7_u6EE4_u67E5_u8BE2Filter_DSL"><a href="#u8FC7_u6EE4_u67E5_u8BE2Filter_DSL" class="headerlink" title="过滤查询Filter DSL"></a>过滤查询Filter DSL</h4><h4 id="term__u8FC7_u6EE4"><a href="#term__u8FC7_u6EE4" class="headerlink" title="term 过滤"></a>term 过滤</h4><pre><code>{
    &quot;term&quot;: {
        &quot;{field}&quot;: {value} 
    }
}
</code></pre><h4 id="terms__u8FC7_u6EE4"><a href="#terms__u8FC7_u6EE4" class="headerlink" title="terms 过滤"></a>terms 过滤</h4><pre><code>{
    &quot;terms&quot;: {
        &quot;{field}&quot;: [ {value1}, {value2} ]
    }
}
</code></pre><h4 id="range_u8FC7_u6EE4"><a href="#range_u8FC7_u6EE4" class="headerlink" title="range过滤"></a>range过滤</h4><pre><code>{
    &quot;range&quot;: {
        &quot;{field}&quot;: {
            &quot;gte&quot;: 20, //gt gte, lt lte
        }
    }
}
</code></pre><h4 id="exits_2C_missing_u8FC7_u6EE4"><a href="#exits_2C_missing_u8FC7_u6EE4" class="headerlink" title="exits, missing过滤"></a>exits, missing过滤</h4><pre><code>{
    &quot;exists&quot;: {
        &quot;field&quot;: &quot;{field}&quot;,//存在这个类型
    }
}
</code></pre><h4 id="u8FC7_u6EE4"><a href="#u8FC7_u6EE4" class="headerlink" title="过滤"></a>过滤</h4><pre><code>{
    &quot;bool&quot;: {
        &quot;must&quot;: {},//必须符合
        &quot;must_not&quot;: {},//必须不符合
        &quot;should&quot;: {},//必须符合其中一个条件
    }
}
</code></pre><h4 id="match_all"><a href="#match_all" class="headerlink" title="match_all"></a>match_all</h4><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><h4 id="multi_match"><a href="#multi_match" class="headerlink" title="multi_match"></a>multi_match</h4><h4 id="u67E5_u8BE2_u6BD4_u8FC7_u6EE4_u591A_u4E86_u76F8_u5173_u6027_u8BA1_u7B97"><a href="#u67E5_u8BE2_u6BD4_u8FC7_u6EE4_u591A_u4E86_u76F8_u5173_u6027_u8BA1_u7B97" class="headerlink" title="查询比过滤多了相关性计算"></a>查询比过滤多了相关性计算</h4><h4 id="u590D_u5408_u67E5_u8BE2"><a href="#u590D_u5408_u67E5_u8BE2" class="headerlink" title="复合查询"></a>复合查询</h4><pre><code>{
    &quot;filtered&quot;: {
        &quot;query&quot;:  { &quot;match&quot;: { &quot;email&quot;: &quot;business opportunity&quot; }},
        &quot;filter&quot;: { &quot;term&quot;:  { &quot;folder&quot;: &quot;inbox&quot; }}
    }
}
</code></pre><h4 id="u9A8C_u8BC1_u67E5_u8BE2_uFF0C_u89E3_u91CA_u9519_u8BEF"><a href="#u9A8C_u8BC1_u67E5_u8BE2_uFF0C_u89E3_u91CA_u9519_u8BEF" class="headerlink" title="验证查询，解释错误"></a>验证查询，解释错误</h4><pre><code>GET /gb/tweet/_validate/query?explain
    {
        &quot;query&quot;: {
            *********
        }
    }
</code></pre><h4 id="u6392_u5E8F_uFF0C_u5728query_u4E4B_u540E"><a href="#u6392_u5E8F_uFF0C_u5728query_u4E4B_u540E" class="headerlink" title="排序，在query之后"></a>排序，在query之后</h4><pre><code>GET /_search
{
    &quot;query&quot;: {
    },
    &quot;sort&quot;: {
        &quot;{field}&quot;:{
            &quot;order&quot;: &quot;desc&quot;
        },
        &quot;{field}&quot;:{
            &quot;order&quot;: &quot;asc&quot;,
            &quot;mode&quot;: &quot;min&quot; //field为多个值时
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u7ED3_u6784_u5316_u67E5_u8BE2Query_DSL"><a href="#u7ED3_u6784_u5316_u67E5_u8BE2Query_DSL" class="headerlink" title="结构化查询Query DSL">]]>
    </summary>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/tags/elasticsearch/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/categories/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[elasticsearch系列笔记(四) 搜索]]></title>
    <link href="http://catlittlechen.com/2016/08/09/es4/"/>
    <id>http://catlittlechen.com/2016/08/09/es4/</id>
    <published>2016-08-09T00:51:19.000Z</published>
    <updated>2017-02-20T13:34:00.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u8DEF_u7531_u6587_u6863_u5230_u5206_u7247"><a href="#u8DEF_u7531_u6587_u6863_u5230_u5206_u7247" class="headerlink" title="路由文档到分片"></a>路由文档到分片</h4><pre><code>shard = hash(routing) % number_of_primary_shards
</code></pre><h4 id="replication"><a href="#replication" class="headerlink" title="replication"></a>replication</h4><pre><code>请求是否需要等待复制分区的成功响应，默认为sync等待，async异步不等待。 
</code></pre><h4 id="consistency"><a href="#consistency" class="headerlink" title="consistency"></a>consistency</h4><pre><code>文档在写入的时候，需要规定一定的分区更新成功之后，才会返回客户端成功，如果节点不够，则不能删除或者索引任何文件

int((primary + number_of_replicas) / 2) + 1
</code></pre><h4 id="u7A7A_u641C_u7D22"><a href="#u7A7A_u641C_u7D22" class="headerlink" title="空搜索"></a>空搜索</h4><pre><code>GET /_search
    hits:
        total 总文档数
        hits 匹配到的数量
        max_score 最大相关性
    took：请求时间
    _shards: 用到的分片大小和类型
GET /_search?size={size}&amp;from={from}
    从from开始最多size个内容返回
</code></pre><h4 id="u7B80_u6613_u641C_u7D22"><a href="#u7B80_u6613_u641C_u7D22" class="headerlink" title="简易搜索"></a>简易搜索</h4><pre><code>GET /_all/{type}/_search?q={field}:{key}
GET /_all/{type}/_search?q=`urlencode(+{field}:{key}-{field}:{key})` +条件满足 -条件不满足
GET /_all/{type}/_search?q={value} 查询包含value的文档
</code></pre><h4 id="u65B0_u5EFA_u7D22_u5F15_uFF0C_u8BBE_u7F6E_u5206_u6790_u5668"><a href="#u65B0_u5EFA_u7D22_u5F15_uFF0C_u8BBE_u7F6E_u5206_u6790_u5668" class="headerlink" title="新建索引，设置分析器"></a>新建索引，设置分析器</h4><pre><code>PUT /{index}
{
    &quot;mappings&quot;: {
        &quot;{type}&quot;: {
            &quot;properties&quot;: {
                &quot;field&quot;: {
                    &quot;type&quot;: &quot;&quot;, //string, date, long, object(嵌套)
                    &quot;index&quot;: &quot;&quot;, // analyzed, not_analyzed, no
                    &quot;analyzer&quot;: &quot;&quot;, // english, space
                }
            }
        }
    }
}
</code></pre><h4 id="u6D4B_u8BD5_u5206_u6790_u5668"><a href="#u6D4B_u8BD5_u5206_u6790_u5668" class="headerlink" title="测试分析器"></a>测试分析器</h4><pre><code>GET /{index}/_analyze?field={field}&amp;text={value}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u8DEF_u7531_u6587_u6863_u5230_u5206_u7247"><a href="#u8DEF_u7531_u6587_u6863_u5230_u5206_u7247" class="headerlink" title="路由文档到分片"><]]>
    </summary>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/tags/elasticsearch/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/categories/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[elasticsearch系列笔记(三) 基本API]]></title>
    <link href="http://catlittlechen.com/2016/08/04/es3/"/>
    <id>http://catlittlechen.com/2016/08/04/es3/</id>
    <published>2016-08-04T12:11:51.000Z</published>
    <updated>2017-02-20T13:35:07.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u6DFB_u52A0_u6587_u6863_2C_u81EA_u5B9A_u4E49ID"><a href="#u6DFB_u52A0_u6587_u6863_2C_u81EA_u5B9A_u4E49ID" class="headerlink" title="添加文档,自定义ID"></a>添加文档,自定义ID</h4><pre><code>PUT /{index}/{type}/{id}
{
    &quot;field&quot;: &quot;value&quot;,
}
</code></pre><h4 id="u6DFB_u52A0_u6587_u6863_uFF0C_u8FD9_u65F6_u5019_u7684ID_u662FES_u81EA_u52A8_u751F_u6210_uFF0C_u4E3A22_u4F4D_u7684UUIDS"><a href="#u6DFB_u52A0_u6587_u6863_uFF0C_u8FD9_u65F6_u5019_u7684ID_u662FES_u81EA_u52A8_u751F_u6210_uFF0C_u4E3A22_u4F4D_u7684UUIDS" class="headerlink" title="添加文档，这时候的ID是ES自动生成，为22位的UUIDS"></a>添加文档，这时候的ID是ES自动生成，为22位的UUIDS</h4><pre><code>POST /{index}/{type}/
{
    &quot;field&quot;: &quot;value&quot;,
}
</code></pre><h4 id="u83B7_u5F97_u6587_u6863"><a href="#u83B7_u5F97_u6587_u6863" class="headerlink" title="获得文档"></a>获得文档</h4><pre><code>GET /{index}/{type}/{id}?pretty
{
    &quot;_index&quot; :   &quot;{index}&quot;,
    &quot;_type&quot; :    &quot;{type}&quot;,
    &quot;_id&quot; :      &quot;{id}&quot;,
    &quot;_version&quot; : 1,
    &quot;found&quot; :    true, //是否找到，404同步返回
    &quot;_source&quot; :  {
        &quot;field&quot;: &quot;value&quot;,
    }
}
</code></pre><h4 id="u83B7_u5F97_u6587_u6863_u7684_u7279_u5B9A_u5C5E_u6027"><a href="#u83B7_u5F97_u6587_u6863_u7684_u7279_u5B9A_u5C5E_u6027" class="headerlink" title="获得文档的特定属性"></a>获得文档的特定属性</h4><pre><code>GET /{index}/{type}/{id}/{key}?pretty
{
    &quot;{key}&quot;: &quot;value&quot;
}
key 为上面json的值
</code></pre><h4 id="u83B7_u5F97_u6587_u6863_u7684_u7279_u5B9A_u503C"><a href="#u83B7_u5F97_u6587_u6863_u7684_u7279_u5B9A_u503C" class="headerlink" title="获得文档的特定值"></a>获得文档的特定值</h4><pre><code>GET /{index}/{type}/{id}?pretty&amp;_source={field1},{field2}
{
    &quot;_index&quot; :   &quot;{index}&quot;,
    &quot;_type&quot; :    &quot;{type}&quot;,
    &quot;_id&quot; :      &quot;{id}&quot;,
    &quot;_version&quot; : 1,
    &quot;found&quot; :    true, //是否找到，404同步返回
    &quot;_source&quot; :  {
        &quot;field1&quot;: &quot;value&quot;,
        &quot;field2&quot;: &quot;value&quot;,
    }
}
</code></pre><h4 id="u68C0_u67E5_u6587_u6863_u662F_u5426_u5B58_u5728"><a href="#u68C0_u67E5_u6587_u6863_u662F_u5426_u5B58_u5728" class="headerlink" title="检查文档是否存在"></a>检查文档是否存在</h4><pre><code>HEAD /{index}/{type}/{id}
</code></pre><h4 id="u66F4_u65B0_u6587_u6863_u7684_u65F6_u5019_uFF0C_u5199_u6CD5_u548C_u63D2_u5165_u65F6_u76F8_u540C"><a href="#u66F4_u65B0_u6587_u6863_u7684_u65F6_u5019_uFF0C_u5199_u6CD5_u548C_u63D2_u5165_u65F6_u76F8_u540C" class="headerlink" title="更新文档的时候，写法和插入时相同"></a>更新文档的时候，写法和插入时相同</h4><pre><code>_version会递增
</code></pre><h4 id="u521B_u5EFA_u6587_u6863_uFF0C_u6210_u529F_u521B_u5EFA_u7684_u65F6_u5019_uFF0C_u8FD4_u56DE201_uFF0C_u5931_u8D25_u8FD4_u56DE409"><a href="#u521B_u5EFA_u6587_u6863_uFF0C_u6210_u529F_u521B_u5EFA_u7684_u65F6_u5019_uFF0C_u8FD4_u56DE201_uFF0C_u5931_u8D25_u8FD4_u56DE409" class="headerlink" title="创建文档，成功创建的时候，返回201，失败返回409"></a>创建文档，成功创建的时候，返回201，失败返回409</h4><pre><code>PUT /{index}/{type}/{id}?op_type=create
PUT /{index}/{type}/{id}/_create
</code></pre><h4 id="u5220_u9664_u6587_u6863_uFF0C_u5931_u8D25_u8FD4_u56DE404"><a href="#u5220_u9664_u6587_u6863_uFF0C_u5931_u8D25_u8FD4_u56DE404" class="headerlink" title="删除文档，失败返回404"></a>删除文档，失败返回404</h4><pre><code>DELETE /{index}/{type}/{id}
</code></pre><h4 id="u66F4_u65B0_u67D0_u4E2A_u7279_u5B9A_u7248_u672C_u7684_u6587_u6863_uFF0C_u7528_u4E8E_u63A7_u5236_u5E76_u53D1_u9519_u8BEF_uFF0Cversion_type_u8BBE_u7F6E_u4E86_u7528_u6B64_u65F6_u7684version_u6765_u8BBE_u7F6E_u6587_u6863_u7684version"><a href="#u66F4_u65B0_u67D0_u4E2A_u7279_u5B9A_u7248_u672C_u7684_u6587_u6863_uFF0C_u7528_u4E8E_u63A7_u5236_u5E76_u53D1_u9519_u8BEF_uFF0Cversion_type_u8BBE_u7F6E_u4E86_u7528_u6B64_u65F6_u7684version_u6765_u8BBE_u7F6E_u6587_u6863_u7684version" class="headerlink" title="更新某个特定版本的文档，用于控制并发错误，version_type设置了用此时的version来设置文档的version"></a>更新某个特定版本的文档，用于控制并发错误，version_type设置了用此时的version来设置文档的version</h4><pre><code>PUT /{index}/{type}/{id}?version={version}
PUT /{index}/{type}/{id}?version={version}&amp;version_type=external
</code></pre><h4 id="u66F4_u65B0_u6587_u6863_u7684_u90E8_u5206_u5185_u5BB9_uFF0C_u5408_u5E76_u6587_u6863"><a href="#u66F4_u65B0_u6587_u6863_u7684_u90E8_u5206_u5185_u5BB9_uFF0C_u5408_u5E76_u6587_u6863" class="headerlink" title="更新文档的部分内容，合并文档"></a>更新文档的部分内容，合并文档</h4><pre><code>POST /{index}/{type}/{id}/_update
</code></pre><h4 id="u811A_u672C_u662F_u4E00_u4E9B_u5947_u602A_u7684_u903B_u8F91_uFF0C_u4E0D_u8FC7_u86EE_u597D_u73A9_u7684_u3002"><a href="#u811A_u672C_u662F_u4E00_u4E9B_u5947_u602A_u7684_u903B_u8F91_uFF0C_u4E0D_u8FC7_u86EE_u597D_u73A9_u7684_u3002" class="headerlink" title="脚本是一些奇怪的逻辑，不过蛮好玩的。"></a>脚本是一些奇怪的逻辑，不过蛮好玩的。</h4><h4 id="u68C0_u7D22_u591A_u4E2A_u6587_u6863"><a href="#u68C0_u7D22_u591A_u4E2A_u6587_u6863" class="headerlink" title="检索多个文档"></a>检索多个文档</h4><pre><code>POST /_mget
{
    &quot;docs&quot;: [
        {
            *******
        }
    ]
}
</code></pre><h4 id="u6279_u91CF_u64CD_u4F5C_uFF0C_u4EE5_u6362_u884C_u7B26_u6765_u5224_u65AD_uFF0C_u9632_u6B62_u4E0D_u5FC5_u8981_u7684json_u89E3_u6790_u7B49_u6570_u636E_u62F7_u8D1D_u3002"><a href="#u6279_u91CF_u64CD_u4F5C_uFF0C_u4EE5_u6362_u884C_u7B26_u6765_u5224_u65AD_uFF0C_u9632_u6B62_u4E0D_u5FC5_u8981_u7684json_u89E3_u6790_u7B49_u6570_u636E_u62F7_u8D1D_u3002" class="headerlink" title="批量操作，以换行符来判断，防止不必要的json解析等数据拷贝。"></a>批量操作，以换行符来判断，防止不必要的json解析等数据拷贝。</h4><pre><code>POST /_bulk
{ action: {metadata }} \n
{ request body } \n
{ action: {metadata }} \n
{ request body } \n
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u6DFB_u52A0_u6587_u6863_2C_u81EA_u5B9A_u4E49ID"><a href="#u6DFB_u52A0_u6587_u6863_2C_u81EA_u5B9A_u4E49ID" class="headerlink" title="]]>
    </summary>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/tags/elasticsearch/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/categories/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[elasticsearch系列笔记(二) 集群安装]]></title>
    <link href="http://catlittlechen.com/2016/08/02/es2/"/>
    <id>http://catlittlechen.com/2016/08/02/es2/</id>
    <published>2016-08-02T12:06:33.000Z</published>
    <updated>2017-02-20T13:20:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="two_es"><a href="#two_es" class="headerlink" title="two es"></a>two es</h3><pre><code>docker run -ti --name es1 elasticsearch /bin/bash
docker run -ti --name es2 elasticsearch /bin/bash
</code></pre><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><pre><code>in es1
vim /etc/elasticsearch/elasticsearch.yml
   cluster.name: elasticsearch-cluster-centos
   node.name: &quot;es-node1&quot;
   bootstrap.mlockall: true
   network.host: 172.17.0.2
   network.publish_host: 172.17.0.2
   discovery.zen.ping.unicast.hosts: [&quot;172.17.0.3&quot;]

in es2
   cluster.name: elasticsearch-cluster-centos
   node.name: &quot;es-node2&quot;
   bootstrap.mlockall: true
   network.host: 172.17.0.3
   network.publish_host: 172.17.0.3
   discovery.zen.ping.unicast.hosts: [&quot;172.17.0.2&quot;]
</code></pre><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><pre><code>/etc/init.d/elasticsearch restart
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="two_es"><a href="#two_es" class="headerlink" title="two es"></a>two es</h3><pre><code>docker run -ti --name es1 elasticsearch /bin/b]]>
    </summary>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/tags/elasticsearch/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/categories/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[elasticsearch系列笔记(一) 基础知识]]></title>
    <link href="http://catlittlechen.com/2016/08/01/es1/"/>
    <id>http://catlittlechen.com/2016/08/01/es1/</id>
    <published>2016-08-01T11:26:21.000Z</published>
    <updated>2017-02-20T13:19:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><pre><code>启动docker
docker run -ti --name es -p 9200:9200 ubuntu:14.04 /bin/bash

更新系统
apt-get update
apt-get upgrade
apt-get install software-properties-common

安装java
add-apt-repository ppa:webupd8team/java
apt-get update
apt-get install oracle-java8-installer

安装es
wget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
echo &quot;deb https://packages.elastic.co/elasticsearch/2.x/debian stable main&quot; &gt;&gt; /etc/apt/sources.list
apt-get update &amp;&amp; apt-get install elasticsearch
update-rc.d elasticsearch defaults 95 10
/etc/init.d/elasticsearch start
</code></pre><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><pre><code>curl -X GET &apos;http://172.17.0.2:9200&apos;
</code></pre><h3 id="install_marvel"><a href="#install_marvel" class="headerlink" title="install marvel"></a>install marvel</h3><pre><code>/usr/share/elasticsearch/bin/plugin -i elasticsearch/marvel/latest
/etc/init.d/elasticsearch restart
</code></pre><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><pre><code>curl -X&lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos;
example :
    curl -XGET &apos;http://172.17.0.2:9200/_count?pretty&apos; -d &apos;
        {
            &quot;query&quot;: {
                &quot;match_all&quot;: {}
            }
        }
    &apos;
    curl -XPUT &apos;http://172.17.0.2:9200/megacorp/employee/1?pretty&apos; -d &apos;
        {
            &quot;first_name&quot; : &quot;John&quot;,
            &quot;last_name&quot; :  &quot;Smith&quot;,
            &quot;age&quot; :        25,
            &quot;about&quot; :      &quot;I love to go rock climbing&quot;,
            &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]
        }
    &apos;
    curl -XGET &apos;http://172.17.0.2:9200/megacorp/employee/1?pretty&apos;
    curl -XGET &apos;http://172.17.0.2:9200/megacorp/employee/_search?pretty&apos;
    curl -XGET &apos;http://172.17.0.2:9200/megacorp/employee/_search?pretty&amp;q=last_name:Smith&apos;
    curl -XGET &apos;http://172.17.0.2:9200/megacorp/employee/_search?pretty&apos; -d &apos;
        {
            &quot;query&quot;: {
                &quot;match&quot;: {
                    &quot;last_name&quot;: &quot;Smith&quot;
                    }
                }
            }
    &apos;
    curl -XGET &apos;http://172.17.0.2:9200/megacorp/employee/_search?pretty&apos; -d &apos;
        {
            &quot;query&quot;: {
                &quot;filtered&quot;: {
                    &quot;filter&quot;: {
                        &quot;range&quot;: {
                            &quot;age&quot;: { &quot;gt&quot;: 20 }
                        }
                    },
                    &quot;query&quot;: {
                        &quot;match&quot;: {
                            &quot;last_name&quot;: &quot;Smith&quot;
                        }
                    }
                }
            }
        }
    &apos;
    curl -XGET &apos;http://172.17.0.2:9200/megacorp/employee/_search?pretty&apos; -d &apos;
        {
            &quot;query&quot; : {
                &quot;match&quot; : {
                    &quot;about&quot; : &quot;rock climbing&quot;
                }
            }
        }
    &apos;
    curl -XGET &apos;http://172.17.0.2:9200/megacorp/employee/_search?pretty&apos; -d &apos;
        {
            &quot;query&quot; : {
                &quot;match_phrase&quot; : {
                    &quot;about&quot; : &quot;rock climbing&quot;
                }
            }
        }
    &apos;
    curl -XGET &apos;http://172.17.0.2:9200/megacorp/employee/_search?pretty&apos; -d &apos;
        {
            &quot;query&quot; : {
                &quot;match_phrase&quot; : {
                    &quot;about&quot; : &quot;rock climbing&quot;
                }
            },
            &quot;highlight&quot;: {
                &quot;fields&quot;: {
                    &quot;about&quot;: {}
                }
            }
        }
    &apos;
    curl -XGET &apos;http://172.17.0.2:9200/megacorp/employee/_search?pretty&apos; -d &apos;
        {
            &quot;aggs&quot;: {
                &quot;all_interests&quot;: {
                    &quot;terms&quot;: { &quot;field&quot;: &quot;interests&quot; }
                }
            }
        }
    &apos;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><pre><code>启动docker
docker run -ti --name es -p 9200:]]>
    </summary>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/tags/elasticsearch/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="elasticsearch" scheme="http://catlittlechen.com/categories/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker-swarm]]></title>
    <link href="http://catlittlechen.com/2016/07/22/docker-swarm/"/>
    <id>http://catlittlechen.com/2016/07/22/docker-swarm/</id>
    <published>2016-07-22T14:51:48.000Z</published>
    <updated>2016-07-22T14:59:49.000Z</updated>
    <content type="html"><![CDATA[<p>前段时间，我和公司的运维朋友一起玩了下docker。在配置docker-swarm的时候，运维朋友可以安逸地开启aws，可怜的我只能默默地在自己的单机上面搭建了~~</p>
<p>所以，才有了今天在用docker-machine来搭建docker-swarm，这份教程基本是按照docker-swram的官方教程改的~</p>
<h4 id="u521B_u5EFAdocker-machine"><a href="#u521B_u5EFAdocker-machine" class="headerlink" title="创建docker-machine"></a>创建docker-machine</h4><pre><code>docker-machine create --driver virtualbox consul
docker-machine create --driver virtualbox manager1
docker-machine create --driver virtualbox manager2
docker-machine create --driver virtualbox node1
docker-machine create --driver virtualbox node2
</code></pre><h4 id="u914D_u7F6Econsul"><a href="#u914D_u7F6Econsul" class="headerlink" title="配置consul"></a>配置consul</h4><p>切换到consul虚机里面：</p>
<pre><code>eval $(docker-machine env consul)
</code></pre><p>启动consul服务：</p>
<pre><code>docker run -d -p 8500:8500 --name=consul progrium/consul -server -bootstrap
</code></pre><h4 id="u914D_u7F6Emanager_u8282_u70B9"><a href="#u914D_u7F6Emanager_u8282_u70B9" class="headerlink" title="配置manager节点"></a>配置manager节点</h4><p>配置manager1节点：</p>
<pre><code>eval $(docker-machine env manager1)
docker run -d -p 4000:4000 -v /var/lib/boot2docker:/certs:ro swarm manage -H :4000 --tlsverify --tlscacert=/certs/ca.pem --tlscert=/certs/server.pem --tlskey=/certs/server-key.pem --replication --advertise $(docker-machine ip manager1):4000 consul://$(docker-machine ip consul):8500
</code></pre><p>配置manager2节点：</p>
<pre><code>eval $(docker-machine env manager2)
docker run -d -p 4000:4000 -v /var/lib/boot2docker:/certs:ro swarm manage -H :4000 --tlsverify --tlscacert=/certs/ca.pem --tlscert=/certs/server.pem --tlskey=/certs/server-key.pem --replication --advertise $(docker-machine ip manager2):4000 consul://$(docker-machine ip consul):8500
</code></pre><h4 id="u914D_u7F6Enode_u8282_u70B9"><a href="#u914D_u7F6Enode_u8282_u70B9" class="headerlink" title="配置node节点"></a>配置node节点</h4><p>配置node1节点</p>
<pre><code>eval $(docker-machine env node1)
docker run -d swarm join --advertise=$(docker-machine ip node1):2376 consul://$(docker-machine ip consul):8500
</code></pre><p>配置node2节点</p>
<pre><code>eval $(docker-machine env node2)
docker run -d swarm join --advertise=$(docker-machine ip node2):2376 consul://$(docker-machine ip consul):8500
</code></pre><h3 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h3><pre><code>docker -H :4000 --tlsverify --tlscacert=/var/lib/boot2docker/ca.pem --tlscert=/var/lib/boot2docker/server.pem --tlskey=/var/lib/boot2docker/server-key.pem run hello-world
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>前段时间，我和公司的运维朋友一起玩了下docker。在配置docker-swarm的时候，运维朋友可以安逸地开启aws，可怜的我只能默默地在自己的单机上面搭建了~~</p>
<p>所以，才有了今天在用docker-machine来搭建docker-swarm，这份教程基本是]]>
    </summary>
    
      <category term="docker" scheme="http://catlittlechen.com/tags/docker/"/>
    
      <category term="docker" scheme="http://catlittlechen.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[思考]]></title>
    <link href="http://catlittlechen.com/2016/06/23/%E6%80%9D%E8%80%83/"/>
    <id>http://catlittlechen.com/2016/06/23/思考/</id>
    <published>2016-06-23T02:24:20.000Z</published>
    <updated>2016-06-23T07:01:36.000Z</updated>
    <content type="html"><![CDATA[<p>从06-09开始，准备写这一篇文章，那天是端午节，在宿舍里面看G3，期待詹姆斯可以赢得这一场比赛，避免被横扫的命运。从那天起，在上班的时候，总是偷偷地看着NBA的文字直播，见证了41-41的G5，爆发的G6，到最后的G7时，我偷偷地带上了耳机，在mac上听起了直播，听完了G7和最后的发布会。也许竞技体育的魅力就在与此，一切皆有可能。06-20，骑士和勇士创造了很多历史，不过是成功夺冠的骑士，还是73胜的勇士，都是一样的伟大。</p>
<p>那一天的发布会上，有位记者问詹姆斯，这次的夺冠和之前的夺冠相比，有什么不同的感受，詹姆斯是这么回答的，“I’m home!”。</p>
<p>这感觉，真好。自从毕业之后，总是少了一点什么，大概也有这个吧。读书时，父母的期望时可以拿到很好的排名和好看的成绩单。那时的我，也没什么想法，只是多看看书，当然，虽然更多的是课外书，但是也是在保持足够的竞争力下。不需要十分刻意地去追求前多少名的成绩，不需要去思考提高语文英语的成绩来弥补短板。那段日子里，我学了很多我想学的知识，通过书籍，去了解很多人的人生。在满足家人和自己的世界里，我活出了自己想要的生活。而如今我顺利地毕业了，成为了一个程序员。但这真的是我想要的么？</p>
<p>我知道不是。</p>
<p>上了社会，虽然作为程序员拿到的工资辉比较高，但是突然发现，在北上广深的世界里，自己所能赚到的工资还是太低太低了。当然，作为一个出入社会的毕业生，自己所能创造的价值实际上也不是很多。很高兴的是，我一再的提醒自己，要守住本心，靠着自己的实力和努力去换取生活的资本。</p>
<p>感谢我小学的老师，教会了我仔细，而我的母亲，则教会了我学会耐心。让我在如此漫长地人生中，学会了成长。而我也很清楚地知道，自己喜欢的是数学，对数字天生的敏感。也许在程序员的领域里面，我更喜欢大数据，或者是人工智能，而不是写业务。我更喜欢知道一个东西为什么这么设计，而不是知道这么东西怎么用。</p>
<p>2016-06-23，一年前，我从大学毕业，用了任性地方式给了自己一份很好的毕业礼物。一年后，我开始反思，我应该自己学习，好好地深入理解后端，去知道更多的为什么，还是应该创作属于自己的作品。</p>
<p>也许其他人无法明白，为什么我不喜欢成功，不喜欢大公司好前景。也许我渴望的自由生活，本就是没有目标的吧。所谓的骄傲，就是靠自己和团队的努力，所获得的成就。希望好好努力，未来会好，世界会更好。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从06-09开始，准备写这一篇文章，那天是端午节，在宿舍里面看G3，期待詹姆斯可以赢得这一场比赛，避免被横扫的命运。从那天起，在上班的时候，总是偷偷地看着NBA的文字直播，见证了41-41的G5，爆发的G6，到最后的G7时，我偷偷地带上了耳机，在mac上听起了直播，听完了G]]>
    </summary>
    
      <category term="生活" scheme="http://catlittlechen.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="活着" scheme="http://catlittlechen.com/categories/%E6%B4%BB%E7%9D%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[multinet]]></title>
    <link href="http://catlittlechen.com/2016/05/20/multinet/"/>
    <id>http://catlittlechen.com/2016/05/20/multinet/</id>
    <published>2016-05-20T06:07:22.000Z</published>
    <updated>2016-07-02T16:17:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h4><p>之前一段时间发现自己用go开发程序的过程中，大部分的时间都是用了标准的HTTP库，而没用到其他方式，比如单纯的TCP。在查看了go的标准库后，发现这个TCP库并没有想象中的好用，因此，我自己开始着手写一个好用点的。</p>
<h4 id="u7ECF_u8FC7"><a href="#u7ECF_u8FC7" class="headerlink" title="经过"></a>经过</h4><p>在解决黏包的问题时，曾经尝试运用go标准库中的json库，将数据打包成为一个结构体的方式，确实时解决了黏包的问题，但是由于go的json库效率不高，整体的效率下下降了2-3倍。最后使用了最简单的模式，通过添加head的方式，达到得知传输的data的长度，进而解决了黏包的问题，而且效率上的影响可以忽略不计。</p>
<p>在解决了黏包的问题之后，我也通过控制代理的模式，发现在高并发的情况下，也许服务端同时需要多次创建or关闭TCP连接，来达到通讯的目的。而实际TCP的使用中，或许大部分时间内，会有TCP连接处于空闲的阶段，那是否可以复用呢？</p>
<p>因此，在multinet中，在一条TCP Connetion被创建的时候，调用库将同时创建n条连接，n为可配置参数。之后返回一个虚拟Conn供代码调用。在实际写入的过程中，conn在接收到调用者的写入之后，空闲的tcp连接会接受这个请求，将数据传给目标，而目标连接会根据读取的数据，分配给指定的虚拟Conn。</p>
<p>在传输的过程中，TCP连接们，会在连接数过少，数据拥挤的时候，自动地创建新的连接来处理数据，当然，服务端也会反馈数据拥挤问题给客户端，让他创建新的连接。当然，这种方式还是比较简单粗暴的～～</p>
<h3 id="u7ED3_u679C"><a href="#u7ED3_u679C" class="headerlink" title="结果"></a>结果</h3><p>一个写着玩的项目，multinet，目前放在了我的github上。地址见右上，在那个也许还没发现的地方。哈哈。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h4><p>之前一段时间发现自己用go开发程序的过程中，大部分的时间都是用了标准的HTTP库，而没用到其他方式，比如]]>
    </summary>
    
      <category term="golang" scheme="http://catlittlechen.com/tags/golang/"/>
    
      <category term="golang" scheme="http://catlittlechen.com/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[golang的debug方式]]></title>
    <link href="http://catlittlechen.com/2016/01/27/golang%E7%9A%84debug%E6%96%B9%E5%BC%8F/"/>
    <id>http://catlittlechen.com/2016/01/27/golang的debug方式/</id>
    <published>2016-01-27T12:11:03.000Z</published>
    <updated>2016-01-27T13:03:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u534F_u7A0B"><a href="#u534F_u7A0B" class="headerlink" title="协程"></a>协程</h2><p>协程是轻量级的线程，在Go语言中对应着goroutine，由Go Runtime管理。由于Go在运行的过程中，如果多个goroutine在同时运行，当且仅当运行这个goroutine的线程被阻塞的时候，调度器也才会运行另外的goroutine。</p>
<h3 id="u8FD9_u5C31_u610F_u5473_u7740"><a href="#u8FD9_u5C31_u610F_u5473_u7740" class="headerlink" title="这就意味着"></a>这就意味着</h3><pre><code>go func() {
    for {
    }
}()
</code></pre><p>这种函数被调用之后，这个goroutine会长期霸占着线程，而其它goroutine就只能饿死在内存中。<br>这种情况下，通过strace -f去跟踪系统调用的debug方式，是无法获取正确的信息。</p>
<h3 id="kill_u5927_u6CD5"><a href="#kill_u5927_u6CD5" class="headerlink" title="kill大法"></a>kill大法</h3><p>Go程序在默认的信号处理中，如果收到了<em>SIGQUIT</em>的信号时，会将正在运行时的goroutine的调用栈输出。即：</p>
<pre><code>kill -3 ***
</code></pre><p>然后知道，自己是怎么坑自己的！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u534F_u7A0B"><a href="#u534F_u7A0B" class="headerlink" title="协程"></a>协程</h2><p>协程是轻量级的线程，在Go语言中对应着goroutine，由Go Runtime管理。由于Go在运行的过]]>
    </summary>
    
      <category term="golang" scheme="http://catlittlechen.com/tags/golang/"/>
    
      <category term="golang" scheme="http://catlittlechen.com/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记一次debug的坑]]></title>
    <link href="http://catlittlechen.com/2015/11/20/%E8%AE%B0%E4%B8%80%E6%AC%A1debug%E7%9A%84%E5%9D%91/"/>
    <id>http://catlittlechen.com/2015/11/20/记一次debug的坑/</id>
    <published>2015-11-20T03:57:00.000Z</published>
    <updated>2016-01-27T11:56:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u611F_u609F"><a href="#u611F_u609F" class="headerlink" title="感悟"></a>感悟</h2><p>这个故事告诉我们，永远不要相信自己的眼睛。</p>
<h2 id="u90A3_u5929"><a href="#u90A3_u5929" class="headerlink" title="那天"></a>那天</h2><p>天气晴朗，阳光明媚~<br>我用Go写了一段程序，程序中需要通过从文件中读取一段文字，然后拼入sql中，然后在数据库中执行。</p>
<p>由于我需要从文件中一行一行的读出数据，我用了这样子的方式读取。</p>
<pre><code>func readLines(path string) (lines []string, err error) {
    var (
            file   *os.File
            part   []byte
            prefix bool
    )

    if file, err = os.Open(path); err != nil {
            return
    }

    reader := bufio.NewReader(file)
    buffer := bytes.NewBuffer(make([]byte, 1024))

    for {
            if part, prefix, err = reader.ReadLine(); err != nil {
                    break
            }
            buffer.Write(part)
            if !prefix {
                    lines = append(lines, buffer.String())
                    buffer.Reset()
            }
    }
    if err == io.EOF {
            err = nil 
    }
    return
}
</code></pre><p>调用的时候，我通过用了大概如下的代码：</p>
<pre><code>lines， err := readLines(userFile)
if err != nil {
    return
}
for _, line := range lines {
    sqlStr := rawSql % line
    _, err = dbConn.Exec(sqlStr)
    if err != nil {
        return
    }
}
</code></pre><p>当然它报错了！这样子的错误信息~</p>
<pre><code>Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos; at line 1
</code></pre><p>通过查阅，我发现这个near ‘’，是的竟然是空的，不像一般的写错sql语句一样是会写明错误信息~<br>瞬间我就神经开始大条了。</p>
<pre><code>难道我后面写漏了什么？  
怎么可能！
不，我得先去喝杯水，然后再来看看。
水果到了，再吃个苹果。
吃完洗个手-。-
我觉得没错啊！
F**k
</code></pre><h2 id="u7ED3_u5C40"><a href="#u7ED3_u5C40" class="headerlink" title="结局"></a>结局</h2><p>不玩了，之所以我会认为自己没错，是因为我将整个sql语句打印了出来，在肉眼确认没错之后，又去mysql得命令行中直接执行了语句，结果十分顺利。<br>最后，十分大条的将从文件中读取出来的lines用长度打印了出来，瞬间我就斯巴达了！  </p>
<pre><code>for _, line := range lines {
    fmt.Printf(&quot;len[%s] is %d&quot;, line, len(line))
    sqlStr := rawSql % line
    fmt.Printf(&quot;sqlStr[%s] is %d&quot;, line, len(sqlStr))
}
</code></pre><p>结果。。。</p>
<pre><code>len[*****] is 1024!
sqlStr[*****] is 1065!
</code></pre><p>这就是为什么我执行失败的原因！sqlStr里面，存在着一段空白的buffer！却是打印不出来的~<br>最后我把代码改成了这样~</p>
<pre><code>data, err = ioutil.ReadAll(userFile)
if err != nil {
    return
}
lines := strings.Split(string(data), &quot;\n&quot;)
</code></pre><h2 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u611F_u609F"><a href="#u611F_u609F" class="headerlink" title="感悟"></a>感悟</h2><p>这个故事告诉我们，永远不要相信自己的眼睛。</p>
<h2 id="u90A3_u5929"><a hr]]>
    </summary>
    
      <category term="golang" scheme="http://catlittlechen.com/tags/golang/"/>
    
      <category term="踩坑日记" scheme="http://catlittlechen.com/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="golang" scheme="http://catlittlechen.com/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[仅仅]]></title>
    <link href="http://catlittlechen.com/2015/11/13/%E4%BB%85%E4%BB%85/"/>
    <id>http://catlittlechen.com/2015/11/13/仅仅/</id>
    <published>2015-11-13T13:12:01.000Z</published>
    <updated>2016-01-27T11:34:19.000Z</updated>
    <content type="html"><![CDATA[<p>独自一人<br>漫步入街头的咖啡厅<br>倚在窗边<br>约定的时刻已经过去<br>又该如何？<br>仅仅因为相信<br>仅仅等待五分钟。    </p>
<p>厅外<br>一辆小吃车<br>一个小女孩站在小凳子上<br>忙碌地为客人做着各式的小吃<br>人来人往<br>钱来食往！</p>
<p>厅内<br>静静地拿起手机<br>熟练地按下号码<br>猛然一惊！<br>却按下了断线<br>仅仅因为相信<br>仅仅等待五分钟。</p>
<p>厅外<br>开始下起小雨<br>小女孩吃力地撑起大篷伞<br>小雨淅沥<br>行人渐少<br>生意也冷清了许多<br>偶尔几个人匆忙而至<br>买了些许离去    </p>
<p>厅内<br>呆呆地看笑着<br>缓缓地按下字母键<br>写完了短信<br>却按了删除一键！<br>凝望着街头的拐角<br>仅仅因为相信<br>仅仅再等五分钟。</p>
<p>厅外<br>小雨渐大<br>环视四周<br>女孩只将车拉至屋檐下<br>为什么？<br>早市也该收了吧    </p>
<p>厅内<br>开始欺骗自己<br>一定会来的<br>站起来转身离开<br>走下台阶<br>第一眼望向街口<br>仅仅因为相信<br>仅仅这样离开<br>只希望自己来得太早太早。</p>
<p>屋檐下<br>那个女孩好像在发抖<br>为什么？<br>服务员说<br>那个欺骗小女孩的人<br>不可能回来的    </p>
<p>台阶下<br>呆呆地<br>她在等待那个人回来吗？<br>为什么就舍得骗她<br>双目开始颤抖<br>降温了<br>转身迈进        </p>
<p>屋檐下<br>女孩说，一定会来的！<br>猛然一怔<br>她笑了。    </p>
<p>屋檐下<br>钱被折成了小花<br>变戏法的送上<br>曾经练习了千遍<br>如今献给了另一个<br>转身离开<br>仅仅因为相信<br>仅仅这样离开</p>
<p>这算是believe<br>里面也隐藏着lie</p>
<p>街上<br>停伫回首<br>女孩朝着反方向离开<br>会吗？<br>仅仅因为相信<br>仅仅这样离开。        </p>
<p>街上<br>停伫<br>回首<br>女孩露出无邪的笑</p>
<p>街头<br>雨还在下<br>风却停了<br>一步步地迈向街头<br>那个身影<br>熟悉到陌生                </p>
<p>–你来啦！<br>–对不起，让你等那么久。。。<br>—-呀，你都湿透了！<br>–没事啦，走吧。<br>–什么？<br>–去吃小吃？<br>–好啊！        </p>
<p>仅仅因为相信。<br>雨在下。<br>天已晴。        </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>独自一人<br>漫步入街头的咖啡厅<br>倚在窗边<br>约定的时刻已经过去<br>又该如何？<br>仅仅因为相信<br>仅仅等待五分钟。    </p>
<p>厅外<br>一辆小吃车<br>一个小女孩站在小凳子上<br>忙碌地为客人做着各式的小吃<br>人来人往<br>钱]]>
    </summary>
    
      <category term="生活" scheme="http://catlittlechen.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="活着" scheme="http://catlittlechen.com/categories/%E6%B4%BB%E7%9D%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nagios和ganglia]]></title>
    <link href="http://catlittlechen.com/2015/11/11/nagios%E5%92%8Cganglia/"/>
    <id>http://catlittlechen.com/2015/11/11/nagios和ganglia/</id>
    <published>2015-11-11T08:32:19.000Z</published>
    <updated>2016-01-27T11:34:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8001_u751F_u5E38_u8C08_u2013_u76D1_u63A7"><a href="#u8001_u751F_u5E38_u8C08_u2013_u76D1_u63A7" class="headerlink" title="老生常谈–监控"></a>老生常谈–监控</h2><p>很远很久以前，看到过运维的同事在搞监控系统，自己这个苦逼的开发也在有空闲的时间里面，玩玩而已。  </p>
<p>服务器是用了腾讯云的，裸机~~，系统是ubuntu的。<br>参考了<a href="http://idevit.nl/node/93" target="_blank" rel="external">idevit</a></p>
<h2 id="INSTALL_NAGIOS"><a href="#INSTALL_NAGIOS" class="headerlink" title="INSTALL NAGIOS"></a>INSTALL NAGIOS</h2><p>这次的安装是源码安装，现在ubuntu的apt-get安装了nagios还是3版本的，所以还是多折腾，去下载源码咯。<br>先安装一些依赖的软件：</p>
<pre><code>apt-get install libperl-dev libpng12-dev libgd2-xpm-dev build-essential php5-gd wget nginx spwan-fcgi fcgiwrap php5-fpm 
</code></pre><p>本次的安装时4.1.1版本的。</p>
<pre><code>wget https://assets.nagios.com/downloads/nagioscore/releases/nagios-4.1.1.tar.gz
wget http://www.nagios-plugins.org/download/nagios-plugins-2.1.1.tar.gz
</code></pre><p>下载解压到服务器之中~</p>
<p>创建用户nagios和用户组nagcmd</p>
<pre><code>adduser --system --no-create-home --disabled-login --group nagios
groupadd nagcmd
usermod -G nagcmd nagios
usermod -a -G nagcmd www-data
</code></pre><p>配置nagios源码安装：</p>
<pre><code>cd nagios-4.1.1
./configure --prefix /usr/local/nagios --sysconfdir=/etc/nagios --with-command-user=nagios --with-command-group=nagcmd
#这里会检测所需的环境~
make all
make install
make install-init
make install-config
make install-commandmode
#这里是将开始编译，安装到指定目录，分发配置文件和配置了命令
</code></pre><p>安装完毕之后,这时候你可以把安装包里面的插件cp过来</p>
<pre><code>cp -rvf contrib/eventhandlers/ /usr/local/nagios/libexec/
chown -R nagios:nagios /usr/local/nagios/libexec/eventhandlers
</code></pre><p>nagios需要验证用户的权限，由于本次安装不想使用apache，选用了nginx，所以这次是通过以下的命令来生产用户验证的文件的。</p>
<pre><code>wget http://trac.edgewall.org/export/10791/trunk/contrib/htpasswd.py
chmod +x htpasswd.py
htpasswd.py -c -b /etc/nagios/htpasswd.users nagiosadmin password
</code></pre><p>这里的nagiosadmin是用户名，而password是密码，如果想要重新修改用户名的话，需要在/etc/nagios/cfg.cfg文件中加入权限。<br>比如用户名是catlittlechen的话，可以修改成下面这样子</p>
<pre><code>authorized_for_system_information=nagiosadmin,catlittlechen
</code></pre><p>安装下nagios官方提供的插件</p>
<pre><code>cd nagios-plugins-2.1.1
./configure --with-nagios-user=nagios --with-nagios-group=nagios
make
make install
</code></pre><p>之后可以通过执行下面的指令来验证下是否成功的配置了nagios</p>
<pre><code>/usr/local/nagios/bin/nagios -v /etc/nagios/nagio.cfg
</code></pre><p>启动的时候，这边的找了下，发现在/etc/rc.d/下，有一个nagios的脚本，就链接过来了/etc/init.d/nagios,然后就可以执行下面的命令启动来。</p>
<pre><code>service nagios start
</code></pre><p>弱弱的说，nginx配置在最下面~</p>
<h3 id="INSTALL_GANGLIA"><a href="#INSTALL_GANGLIA" class="headerlink" title="INSTALL GANGLIA"></a>INSTALL GANGLIA</h3><p>安装ganglia只是为了便捷的弥补下nagios只有定时检测的特性，当然，你可以尝试安装pnp4nagios来完成这个功能，但是ganglia更加的强大一些，而且真得简单啊。<br>命令：</p>
<pre><code>apt-get install -y ganglia-monitor rrdtool gmetad ganglia-webfrontend
</code></pre><p>这时候需要修改两个地方的配置文件</p>
<pre><code>vim /etc/ganglia/gmetad.conf
#data_source &quot;my cluster&quot; localhost
data_source &quot;cat chen&quot; localhost
vim /etc/ganglia/gmond.conf
cluster {
    #name = &quot;unspecified&quot;
    name = &quot;cat chen&quot;
    owner = &quot;unspecified&quot;
    latlong = &quot;unspecified&quot;
    url = &quot;unspecified&quot;
}
udp_send_channel  {
    #mcast_join = 239.2.11.71
    host = localhost
    port = 8649
    ttl = 1
}
udp_recv_channel {
    #mcast_join = 239.2.11.71
    port = 8649
    #bind = 239.2.11.71
}
</code></pre><p>然后执行下面的语句重启下服务</p>
<pre><code>service ganglia-monitor restart &amp;&amp; service gmetad restart
</code></pre><p>杠杠的，ganglia就这么搞定了~<br>这里为了习惯问题，我还执行了以下的命令</p>
<pre><code>cp -r /usr/share/ganglia-webfrontend/  /var/www/
mv /var/www/ganglia-webfrontend /var/www/ganglia
</code></pre><h3 id="Nagios__26amp_3B_26amp_3B_Ganglia"><a href="#Nagios__26amp_3B_26amp_3B_Ganglia" class="headerlink" title="Nagios &amp;&amp; Ganglia"></a>Nagios &amp;&amp; Ganglia</h3><p>最后，当然是配合ganglia和nagios了。</p>
<pre><code>git clone https://github.com/ganglia/monitor-core/
cp monitor-core/contrib/check_ganglia.py /usr/local/nagios/libexec
chown nagios:nagios check_ganglia.py
chmod +x check_ganglia.py
</code></pre><p>为了让nagios可以使用这个插件，需要在command配置中加入以下的配置</p>
<pre><code>vim /etc/nagios/objects/commands.cfg
define command {
    command_name check_ganglia
    command_line $USER1$/check_ganglia.py -h $HOSTNAME$ -m $ARG1$ -w $ARG2$ -c $ARG3$
}
</code></pre><p>然后就可以在配置项目里面配置相应的监控目标，比如我简答的配置如下</p>
<pre><code>vim /etc/nagios/objects/localhost.cfg
define service {
    use     local-service
    host_name       localhost
    service_description     Ganglia Bytes Out
    check_command   check_ganglia!bytes_out!80000!100000
}

define service {
    use     local-service
    host_name       localhost
    service_description     Ganglia Disk Free
    check_command   check_ganglia!disk_free!20!10
}
</code></pre><p>更加详细的配置，好书推荐，可以参考下<a href="http://nagios-cn.sourceforge.net/nagios-cn/configuration.html" target="_blank" rel="external">nagios_cn</a></p>
<h3 id="nginx_u914D_u7F6E_uFF1A"><a href="#nginx_u914D_u7F6E_uFF1A" class="headerlink" title="nginx配置："></a>nginx配置：</h3><pre><code>server {
    listen 10086
    server_name nagios.catlittlechen.com;
    access_log  /var/log/nginx/nagios.access.log;
    error_log   /var/log/nginx/nagios.error.log;

      auth_basic            &quot;Restricted Nagios Area!&quot;;
      auth_basic_user_file  /etc/nagios/htpasswd.users;

    root    /var/www;
    index   index.php index.html;

    location /nagios {
        index index.php;
        alias /usr/local/nagios/share/;
    }

    location /ganglia {
        index index.php index.html index.htm;
    }

    location ~ ^/nagios/(.*\.php)$ {
        alias /usr/local/nagios/share/$1;
        include /etc/nginx/fastcgi.conf;
        fastcgi_pass unix:/var/run/php5-fpm.sock;
    }

    location ~ \.cgi$ {
        root /usr/local/nagios/sbin/;
        rewrite ^/nagios/cgi-bin/(.*)\.cgi /$1.cgi break;
        fastcgi_param AUTH_USER $remote_user;
        fastcgi_param REMOTE_USER $remote_user;
        include /etc/nginx/fastcgi.conf;
        fastcgi_pass unix:/var/run/fcgiwrap.socket;
    }

    location ~ \.php$ {
        include /etc/nginx/fastcgi.conf;
        fastcgi_pass unix:/var/run/php5-fpm.sock;
    }

    location ~ /\.ht {
            deny all;
    }
}
</code></pre><p>晒图，别吐槽我的垃圾服务器</p>
<p><img src="http://7xnn4y.com1.z0.glb.clouddn.com/E73986A3-89CE-4BDF-8601-CC53F38C64ED.png" alt="ganglia"><br><img src="http://7xnn4y.com1.z0.glb.clouddn.com/76CE6A52-D7EC-42B8-90B5-C34B1D596421.png" alt="nagios"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8001_u751F_u5E38_u8C08_u2013_u76D1_u63A7"><a href="#u8001_u751F_u5E38_u8C08_u2013_u76D1_u63A7" class="headerlink" title="老生常谈–监控"><]]>
    </summary>
    
      <category term="ganglias" scheme="http://catlittlechen.com/tags/ganglias/"/>
    
      <category term="nagios" scheme="http://catlittlechen.com/tags/nagios/"/>
    
      <category term="监控" scheme="http://catlittlechen.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="折腾" scheme="http://catlittlechen.com/categories/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自建DNS服务器]]></title>
    <link href="http://catlittlechen.com/2015/10/19/%E8%87%AA%E5%BB%BADNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://catlittlechen.com/2015/10/19/自建DNS服务器/</id>
    <published>2015-10-19T11:41:33.000Z</published>
    <updated>2016-01-27T11:34:47.000Z</updated>
    <content type="html"><![CDATA[<p>今天有时间，我想看下自己建立DNS服务器，是怎么样的流程。<br>结果发现是如此的简单。</p>
<p>以下是基于ubuntu的。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名管理系统DNS(Domain Name System)，是通过域名来解析到IP的一种网络服务，自建DNS服务器，可以在内网中，自己设定特定的域名解析，达到内网机器可以无需配置host，达到访问内网服务的作用。</p>
<h3 id="DNS_u8BB0_u5F55_28_u5907_u5FD8_29_uFF1A"><a href="#DNS_u8BB0_u5F55_28_u5907_u5FD8_29_uFF1A" class="headerlink" title="DNS记录(备忘)："></a>DNS记录(备忘)：</h3><ul>
<li>A记录：        主机名或者域名 –&gt; 相应的IP地址；</li>
<li>NS记录：        记录域名有哪些DNS服务器来解析；</li>
<li>CNAME记录：    将域名的解析转到另外一个域名上去；</li>
<li>MX记录：        一个网络里面的电子邮件服务引导到特定服务器；</li>
<li>TXT记录：        提供了域名的文本信息；</li>
</ul>
<h2 id="Bind9"><a href="#Bind9" class="headerlink" title="Bind9"></a>Bind9</h2><p>bind(berkeley Internet Name Daemon)<br>建立DNS服务器，在ubuntu下只需要安装bind9就可以了。<br>    <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install bind9</span><br></pre></td></tr></table></figure></p>
<h3 id="u670D_u52A1_u5668"><a href="#u670D_u52A1_u5668" class="headerlink" title="服务器"></a>服务器</h3><p>bind9可以配置多种DNS服务器:</p>
<ol>
<li>缓冲服务器，用于缓存DNS服务，减少带宽使用；</li>
<li>主服务器，用于记录DNS服务信息；</li>
<li>从服务器，完整的备份主服务器的内容；</li>
<li>混合服务器，多种服务器合并的累心；</li>
<li>私用的主从服务器；</li>
</ol>
<h3 id="u4E3B_u8981_u914D_u7F6E"><a href="#u4E3B_u8981_u914D_u7F6E" class="headerlink" title="主要配置"></a>主要配置</h3><pre><code>cd /etc/bind/
</code></pre><p>可以看出在目录下面有多个name.conf*的文件，为配置文件；db.*的文件为DNS记录文件；*.keys文件是Bind在交互过程中用于检验的秘钥。    </p>
<h4 id="name-conf-options"><a href="#name-conf-options" class="headerlink" title="name.conf.options"></a>name.conf.options</h4><ul>
<li>forwarders: 选择现有的DNS提供商，以’;’分割，如果不写的话，这个地方会被默认为root名称服务器来解析，速度会特别慢；</li>
<li>directory “filename”: 用于存放该区域数据的文件；</li>
<li>forward first: 在尝试通过root服务器解析DNS请求先，对DNS请求进行转发(forward only 不进行转发)；</li>
<li>listen-on port *port{ ip-address;}: 指定监听哪一些网络接口(默认是127.0.0.1或者localhost)或者哪一个端口(默认是53)来监听客户端的查询；</li>
<li>listen-on-v6 *port{any;}: 指定Bind通过哪一个多端口去监听IPv6的客户端请求，any只可以被none代替；</li>
<li>query-source[-v6] address <em> port </em>: 服务器在查询解析的域名的时候，是有可能查询不到的而向其他服务器查询，因此，query-source可以设定这类查询采用什么样的地址和端口。这里的port只用于UDP的请求，TCP请求会随机使用一个大于1024的端口；</li>
<li>allow_query {ip-address;}: 指定说哪一些IP的网络可以进行普通的查询；</li>
<li>allow_transfer: 指定说哪一些IP的网络可以进行域的传输；</li>
<li>statistics-interval: 生成统计信息；设置为0，则不生成；</li>
<li>cleaning-interval: 缓存时间；</li>
<li>interface-interval: 定期检测网络接口中存在的接口，设置为0，则不扫描；</li>
<li>notify no: 在区域数据改动或者重启服务时，是否通知其他服务器；</li>
<li>dump-file “filename”: 执行rndc dumpdb时，存放的路径；</li>
</ul>
<h4 id="name-conf_logging"><a href="#name-conf_logging" class="headerlink" title="name.conf logging"></a>name.conf logging</h4><pre><code> logging {
       [ channel channel_name {
         ( file path_name
         [ versions ( number | unlimited ) ]
         [ size size_spec ]
         [ syslog (syslog_facility） | stderr | null)];
         [ severity (critical | error | warning | notice | info | debug [ level ] | dynamic ); ]
         [ print-category yes | no; ]
         [ print-severity yes | no; ]
         [ print-time yes | no; ]
       }; ]
       [ category category_name {
         channel_name ; [ channel_name ; ... ]
       }; ]
       ...
};
</code></pre><ul>
<li>file: 日志文件的路径；</li>
<li>versions, size: 用于控制日志文件的版本；<ol>
<li>如果size设置，versions没有设置，则写满日志文件之后，就会停止写入；</li>
<li>如果size，versions设置，则写满日志文件之后，会更新日志文件版本，继续写入；</li>
<li>如果size没设置，versions设置了，将会在Bind重启的时候再更新日志文件的版本；</li>
</ol>
</li>
<li>syslog, stderr, null: 三个参数填写出其中的一个，syslog会将输出的信息输出到系统日志中，详细的配置可以看下syslog，stderr将通道的输出信息重定向到标准错误流中，null则是忽略信息；</li>
<li>category: 这一部分的信息其实是将特定的输出内容写入指定的通道之中；具体有哪些种类的输出内容可以看下官方的介绍，种类太多也就不想列了。</li>
</ul>
<h4 id="name-conf_zone"><a href="#name-conf_zone" class="headerlink" title="name.conf zone"></a>name.conf zone</h4><p>在配置文件中，有name.conf.defaul-zones文件，已经默认的添加了部分DNS记录，而自建dns服务器，达到内网解析的关键，也就是配置这部分的文件。  </p>
<p>zone的配置模板目下所示：</p>
<pre><code>zone “catchenii.com” in {
    type master;
    file &quot;/etc/bind/db.catchenii.com&quot;
}
</code></pre><ul>
<li>type: 指DNS服务器的类型，分别为master(主服务器)，slave(从服务器)，hint(区域服务器)；</li>
<li>file: 区域数据文件；</li>
<li>master{server-ip-address}: 从服务器配置指定从哪个服务器中获取区域数据文件；</li>
<li>allow-update{!*;}: 是否允许外部创建DNS数据文件，默认是禁止的。(这一项就决定着有可能可以动态更新内网的DNS信息)  </li>
</ul>
<p>而对应的<strong>/etc/bind/db.catchenii.com</strong>区域数据文件则如图所示：<br><img src="http://7xnn4y.com1.z0.glb.clouddn.com/2.png" alt="db.catchenii.com"><br>区域文件有两种，一种是IP-&gt;域名，另外一种是域名-&gt;IP,上图当然是域名到IP得数据文件，两份记录的格式也是基本一致：</p>
<pre><code>&apos;.&apos;在区域文件中是由重要的含义的，如果域名没有在末尾加入&apos;.&apos;，则会追加域名在后面，完整的域名必须在末尾加&apos;.&apos;。
</code></pre><ul>
<li>$TTL: 默认的存活时间；</li>
<li>SOA: Start Of Authority 控制记录开始的位置。IN SOA后面是作为该区域的主服务器的名称。</li>
<li>Serial: 每修改一次文件，数字都会添加，用于告诉从服务器改变的通知；</li>
<li>Refresh: 下级服务器来校验serial number的时间间隔；</li>
<li>Retry: 下级服务器连接主服务器时出现错误的重试时间间隔；</li>
<li>Expire: 下级服务器无法联系主服务器时，缓存的超时时间；</li>
<li>Negative Cache TTL: 解析失败的记录的缓存时间；  </li>
</ul>
<p>接下来的数据为DNS的解析记录啦！</p>
<h3 id="u7ED3_u679C"><a href="#u7ED3_u679C" class="headerlink" title="结果"></a>结果</h3><p>修改好文件之后，可以重启下服务：</p>
<pre><code>sudo /etc/init.d/bind9 restart
</code></pre><p>效果如图所示：<br><img src="http://7xnn4y.com1.z0.glb.clouddn.com/3.png" alt="结果图"></p>
<p>嘻嘻。</p>
<h2 id="u5907_u8BB0_uFF1A"><a href="#u5907_u8BB0_uFF1A" class="headerlink" title="备记："></a>备记：</h2><p>各类DNS服务器的<a href="https://en.wikipedia.org/wiki/Comparison_of_DNS_server_software" target="_blank" rel="external">比较</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天有时间，我想看下自己建立DNS服务器，是怎么样的流程。<br>结果发现是如此的简单。</p>
<p>以下是基于ubuntu的。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS<]]>
    </summary>
    
      <category term="技术" scheme="http://catlittlechen.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="折腾" scheme="http://catlittlechen.com/categories/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[虚拟化技术了解]]></title>
    <link href="http://catlittlechen.com/2015/09/29/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/"/>
    <id>http://catlittlechen.com/2015/09/29/虚拟化技术了解/</id>
    <published>2015-09-29T12:05:17.000Z</published>
    <updated>2016-01-27T11:35:04.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u67D0_u4E00_u5929_uFF0Cdocker_u706B_u4E86_uFF01"><a href="#u67D0_u4E00_u5929_uFF0Cdocker_u706B_u4E86_uFF01" class="headerlink" title="某一天，docker火了！"></a>某一天，docker火了！</h4><p>相信第一个看了docker的人，当然，不是我这种菜鸟，都会很快的了解到docker所利用的技术和理论，其实早在多年之前，就已经被提出。</p>
<h3 id="LXC_3A"><a href="#LXC_3A" class="headerlink" title="LXC:"></a>LXC:</h3><p>lxc(Linux Containers)，是一种基于<strong>容器</strong>的操作系统层次的虚拟化技术，通过<strong>cgroup</strong>来控制硬件分配的，如CPU的使用率，内存的最大使用值等，通过<strong>namespace</strong>来隔离硬件环境。<br>这个点上推荐下陈皓先生的<a href="http://coolshell.cn/articles/17049.html" target="_blank" rel="external">文章</a>,通过了浅显易通的描述，可以帮读者更好的了解下docler及其运用的技术。</p>
<h3 id="KVM_uFF1A"><a href="#KVM_uFF1A" class="headerlink" title="KVM："></a>KVM：</h3><p>KVM(kernel-bases Virtual Machine),是基于Linux的<strong>hypervisor</strong>解决方案，也是首个被集成到Linux内核的hypervisor解决方案，并且是实现了完整的虚拟化的。新的操作系统会成为宿主操作系统的一个进程，通过/dev/kvm设备映射，拥有了自己的虚拟地址，因此，kvm是用了底层硬件的虚拟化支持来提供完整的虚拟化。</p>
<h2 id="SO_uFF1A"><a href="#SO_uFF1A" class="headerlink" title="SO："></a>SO：</h2><p>在虚拟化的性能方面，通过cgroup和namespace等技术的LXC会远超过KVM，但是虚拟化隔离方面，lxc只能说是达到了资源的控制和隔离，而不是真正意义上的硬件隔离，毕竟当你更新了宿主系统上面的一个关键程序的时候，lxc上的容器将很大程度上会收到影响，而kvm拥有完整的操作系统的虚拟化则不会受影响。<br>一切都是有代价的，取舍适当即可。<br>这里有一篇<a href="http://blog.chinaunix.net/uid-20662820-id-4514947.html" target="_blank" rel="external">文章</a>，博主通过测试数据，展示了LXC，KVM还有另外一种虚拟化技术XEN的性能数据。</p>
<p>目前，除了<a href="https://www.docker.com/" target="_blank" rel="external">Docker</a>外，目前国内还有另外一个值得关注的项目<a href="https://hyper.sh/" target="_blank" rel="external">hyper</a>,是基于hypervisor与docker的项目。</p>
<h3 id="TODO_3A"><a href="#TODO_3A" class="headerlink" title="TODO:"></a>TODO:</h3><p>了解下XEN，OVS，CEPH等，写写测试。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u67D0_u4E00_u5929_uFF0Cdocker_u706B_u4E86_uFF01"><a href="#u67D0_u4E00_u5929_uFF0Cdocker_u706B_u4E86_uFF01" class="headerlink" title]]>
    </summary>
    
      <category term="虚拟化" scheme="http://catlittlechen.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++的模板类]]></title>
    <link href="http://catlittlechen.com/2015/09/25/c%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB/"/>
    <id>http://catlittlechen.com/2015/09/25/c的模板类/</id>
    <published>2015-09-24T23:56:37.000Z</published>
    <updated>2016-01-27T12:50:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h2><p>昨天帮一个同学debug一个问题，想想也是醉了，太久没写C++，报错信息都看着陌生，还好有万能的<a href="https://www.google.com.hk/" target="_blank" rel="external">Google</a>，让我从<a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow</a>中找到了答案。</p>
<h2 id="u5F00_u59CB_u8BB2_u6545_u4E8B"><a href="#u5F00_u59CB_u8BB2_u6545_u4E8B" class="headerlink" title="开始讲故事"></a>开始讲故事</h2><p>C++标准库的书中，曾经说过这么一句话</p>
<pre><code>唯一一种方便的使用模板类的方法是用内联函数的方式在头文件中一次性实现。
</code></pre><h3 id="u4E3A_u4EC0_u4E48_u5462_uFF1F"><a href="#u4E3A_u4EC0_u4E48_u5462_uFF1F" class="headerlink" title="为什么呢？"></a>为什么呢？</h3><p>对于一个模板类，编译器在实例化的时候，通过模板类的参数，会创建一个新的类，举个例子：</p>
<pre><code>template&lt;typename T&gt;
struct Foo
{
  T bar;
  void doSomething(T param) {}
};

// somewhere in a .cpp
Foo&lt;int&gt; f; 
</code></pre><p>当编译器读到下面这一行的时候，就会创建一个新的类，我们可以把它叫做FooInt，这个类的实现等价于下面这种模式：</p>
<pre><code>struct FooInt
{
  int bar;
  void doSomething(int param) {}
}
</code></pre><p>因此，编译器开始需要去实现里面类的方法，自然是通过模板的参数来实现它们。如果这些实现不在头文件里面，编译器就无法获取到这些模板，自然就无法实现模板类的方法了。</p>
<hr>
<h3 id="u65B9_u6CD5_uFF1A"><a href="#u65B9_u6CD5_uFF1A" class="headerlink" title="方法："></a>方法：</h3><p>当然，将函数的声明和实现放在多个文件中，有时候是非常有必要的，简洁，条理，或者强迫症。。。<br>一种简单的解决方案是在头文件中声明类的方法之后，把类的实现写在文件B中，然后再头文件中include文件B，如下所示：</p>
<pre><code>// 在Foo.h中声明；
template &lt;typename T&gt;
struct Foo
{
  void doSomething(T param);
};
//include 实现的文件；
#include &quot;Foo.tpp&quot;

// 在Foo.tpp中实现函数；
template &lt;typename T&gt;
void Foo&lt;T&gt;::doSomething(T param)
{
    //implementation
}
</code></pre><p>哈哈，这是一种十分取巧的方法，不过也达到了目的，而且效果拔群。<br>还有一种方法，感觉上就不是很推荐了，但是更加正常一些。</p>
<pre><code>// Foo.h
// no implementation
template &lt;typename T&gt; struct Foo { ... };

// Foo.cpp
// implementation of Foo&apos;s methods
// explicit instantiations
template class Foo&lt;int&gt;;
template class Foo&lt;float&gt;;
</code></pre><p>这种方法就是在cpp文件中，实现的模板类的函数之后，在文件中同时将你想要使用的模板参数，明确的实例化出来。  </p>
<p>本人还是比较喜欢第一种，毕竟  </p>
<pre><code>1.我不喜欢一个模板类实现在一个文件里，过长的文件真得太受不了了。
2.第二种方法也就必须把所有的模板类函数实现在一个文件里！
</code></pre><p>博文翻译于<a href="http://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file" target="_blank" rel="external">stackoverflow</a>.</p>
<h4 id="TODO_uFF1A"><a href="#TODO_uFF1A" class="headerlink" title="TODO："></a>TODO：</h4><p>可以看下答主推荐的<a href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl" target="_blank" rel="external">文章</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h2><p>昨天帮一个同学debug一个问题，想想也是醉了，太久没写C++，报错信息都看着陌生，还好有万能的<a h]]>
    </summary>
    
      <category term="c++" scheme="http://catlittlechen.com/tags/c/"/>
    
      <category term="踩坑日记" scheme="http://catlittlechen.com/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="c++" scheme="http://catlittlechen.com/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]solr boolean operators]]></title>
    <link href="http://catlittlechen.com/2015/09/23/%E8%AF%91-solr-boolean-operators/"/>
    <id>http://catlittlechen.com/2015/09/23/译-solr-boolean-operators/</id>
    <published>2015-09-23T13:24:58.000Z</published>
    <updated>2016-01-27T11:35:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8E29_u5751_u611F_u8A00_uFF1A"><a href="#u8E29_u5751_u611F_u8A00_uFF1A" class="headerlink" title="踩坑感言："></a>踩坑感言：</h2><p>这个故事告诉我，<strong>做事情不要想当然</strong>，你觉得的事情，一定不是对的。</p>
<hr>
<h2 id="u8BD1_u6587_u539F_u6587_uFF1A"><a href="#u8BD1_u6587_u539F_u6587_uFF1A" class="headerlink" title="译文原文："></a>译文原文：</h2><p>来自于<a href="http://robotlibrarian.billdueber.com/2011/12/solr-and-boolean-operators/" target="_blank" rel="external">Bill Dueber</a>.</p>
<hr>
<h2 id="u7ED3_u8BBA_uFF1A"><a href="#u7ED3_u8BBA_uFF1A" class="headerlink" title="结论："></a>结论：</h2><p>在Solr中一定要用括号去管理优先级！！！</p>
<hr>
<h6 id="u641E_u8D77_u641E_u8D77_uFF01"><a href="#u641E_u8D77_u641E_u8D77_uFF01" class="headerlink" title="搞起搞起！"></a>搞起搞起！</h6><p>用过Solr的同学知道一下查询，Solr是怎么做的么？</p>
<pre><code>a OR b AND C
</code></pre><p>我可以给你三种选择，但是前两种肯定是错误的，而且你也不会想到第三种，因此还是不要花费太多的时间去想吧。</p>
<h3 id="boolean_u8FD0_u7B97_u7B26_u7684_u4F18_u5148_u7EA7"><a href="#boolean_u8FD0_u7B97_u7B26_u7684_u4F18_u5148_u7EA7" class="headerlink" title="boolean运算符的优先级"></a>boolean运算符的优先级</h3><p>如果你曾经知道过boolean运算相关的知识，你坑定为知道一个严格意义上的顺序，那就是NOT&gt;AND&gt;OR，因此，可能就会使下面一种执行顺序：</p>
<pre><code>a OR (b AND c)
</code></pre><p>这是猜想答案的一种，但是Solr不是这么做的。</p>
<h3 id="u4ECE_u5DE6_u5230_u53F3_uFF1F"><a href="#u4ECE_u5DE6_u5230_u53F3_uFF1F" class="headerlink" title="从左到右？"></a>从左到右？</h3><p>部分本地的学生，或者说也有至少一门编程语言，用的是简单的从左到右的执行方法，因此，就会有如下的一种执行顺序：</p>
<pre><code>（a OR b) AND c
</code></pre><p>不幸的是，这个还是错的。</p>
<h3 id="u90A3_u4E48_u8FD8_u6709_u4EC0_u4E48_u7B54_u6848_u5462_uFF1F"><a href="#u90A3_u4E48_u8FD8_u6709_u4EC0_u4E48_u7B54_u6848_u5462_uFF1F" class="headerlink" title="那么还有什么答案呢？"></a>那么还有什么答案呢？</h3><p>正确的执行顺序可以用如下的代码来表示，待会再通过lucene的查询分析来解释下：</p>
<pre><code>（b AND c）
</code></pre><p>在这里，第一个判断被抛弃了！也就是说，第一个判断其实是可有可无的！</p>
<h3 id="u4F60_u8FD8_u4F1A_u8BA9_u4F60_u7684_u4F7F_u7528_u8005_u5C06AND/OR/NOT_u653E_u5728_u4ED6_u4EEC_u7684_u67E5_u8BE2_u91CC_u4E48_uFF1F"><a href="#u4F60_u8FD8_u4F1A_u8BA9_u4F60_u7684_u4F7F_u7528_u8005_u5C06AND/OR/NOT_u653E_u5728_u4ED6_u4EEC_u7684_u67E5_u8BE2_u91CC_u4E48_uFF1F" class="headerlink" title="你还会让你的使用者将AND/OR/NOT放在他们的查询里么？"></a>你还会让你的使用者将AND/OR/NOT放在他们的查询里么？</h3><p>但愿他们并不知道什么是boolean运算；如果他们知道，但愿他们会使用括号，或者你可以帮他们判断出来，不然，他们将会死得很惨。。。。</p>
<h3 id="u66F4_u591A_u7684_u6D4B_u8BD5"><a href="#u66F4_u591A_u7684_u6D4B_u8BD5" class="headerlink" title="更多的测试"></a>更多的测试</h3><p>我在Solr(3.5)的里面测试下所有可以的情况（用的是curly，larry，moe和shemp的排序）总共有15种情况。</p>
<p>我写了个脚本来跑这些情况，分别在lucene和edismax下，看看可以得到什么样的结果。所有的测试中，lucene的默认运算符是AND，edismax的mm参数设置为100%</p>
<pre><code>Lucene                    EDismax
</code></pre><hr>
<ol>
<li>curly AND larry</li>
</ol>
<pre><code>curly larry               curly larry
curly larry moe           curly larry moe
curly larry shemp         curly larry shemp
curly larry moe shemp     curly larry moe shemp
</code></pre><ol>
<li>curly AND larry OR moe</li>
</ol>
<pre><code>curly                     curly larry
curly larry               curly larry moe
curly moe                 curly larry shemp
curly shemp               curly larry moe shemp
curly larry moe
curly larry shemp
curly moe shemp
curly larry moe shemp
</code></pre><ol>
<li>curly OR larry AND moe</li>
</ol>
<pre><code>larry moe                 larry moe
curly larry moe           curly larry moe
larry moe shemp           larry moe shemp
curly larry moe shemp     curly larry moe shemp
</code></pre><ol>
<li>curly AND larry OR moe AND shemp</li>
</ol>
<pre><code>curly moe shemp           curly larry moe shemp
curly larry moe shemp
</code></pre><ol>
<li>moe AND shemp OR curly AND larry</li>
</ol>
<pre><code>curly larry moe           curly larry moe shemp
curly larry moe shemp
</code></pre><p>查询1的答案是在预想中的。查询2的答案中，明显的就发现在lucene查询器下只有有’curly’就可以了，而在edismax下就需要’curly AND larry’（查询3一样的是变成了’larry AND moe’）。查询4和查询5也是同样的道理。当然，你可以看下debug查询输出，来知道她们是什么样的运行结果，但是没有告诉我为什么。</p>
<h3 id="u542F_u793A"><a href="#u542F_u793A" class="headerlink" title="启示"></a>启示</h3><p>好消息就是，不论是lucene还是edismax，在用括号的时候，她们的答案都是显而易见的。<br>在lucene-167cene的缺陷管理中也确实提到了这个问题(<a href="https://issues.apache.org/jira/browse/LUCENE-167" target="_blank" rel="external">Lucene-167</a>,<a href="https://issues.apache.org/jira/browse/LUCENE-1823" target="_blank" rel="external">lucene-1823</a>)，而在<a href="http://www.mail-archive.com/java-user@lucene.apache.org/msg00008.html" target="_blank" rel="external">2005 mailling list thread</a>中也指出也这种现象，但是它还是仍旧存在。</p>
<p>~~~</p>
<p>还是老老实实的用上括号吧，以免再入坑！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8E29_u5751_u611F_u8A00_uFF1A"><a href="#u8E29_u5751_u611F_u8A00_uFF1A" class="headerlink" title="踩坑感言："></a>踩坑感言：</h2><p>这个故事告诉我，<s]]>
    </summary>
    
      <category term="solr" scheme="http://catlittlechen.com/tags/solr/"/>
    
      <category term="翻译" scheme="http://catlittlechen.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="踩坑日记" scheme="http://catlittlechen.com/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <link href="http://catlittlechen.com/2015/09/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/"/>
    <id>http://catlittlechen.com/2015/09/22/第一篇博文/</id>
    <published>2015-09-22T13:24:52.000Z</published>
    <updated>2016-01-27T11:34:32.000Z</updated>
    <content type="html"><![CDATA[<p>你好，世界</p>
<hr>
<p>今天是拿到mac的第二天，兑现我的承诺，开始写属于自己的文字。</p>
<p>人类总是任性和懒惰，多么好的条件都不会造就一个人，也就是<strong>生于忧患，死于安乐</strong>吧。</p>
<p>好好奋斗，人生才刚刚开始。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>你好，世界</p>
<hr>
<p>今天是拿到mac的第二天，兑现我的承诺，开始写属于自己的文字。</p>
<p>人类总是任性和懒惰，多么好的条件都不会造就一个人，也就是<strong>生于忧患，死于安乐</strong>吧。</p>
<p>好好奋斗，人生才刚刚开始。</p]]>
    </summary>
    
      <category term="生活" scheme="http://catlittlechen.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="起点" scheme="http://catlittlechen.com/tags/%E8%B5%B7%E7%82%B9/"/>
    
      <category term="活着" scheme="http://catlittlechen.com/categories/%E6%B4%BB%E7%9D%80/"/>
    
  </entry>
  
</feed>
