<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[CatChen]]></title>
  <subtitle><![CDATA[我的王国，我一定会让你永垂不朽的]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://catlittlechen.com/"/>
  <updated>2016-01-27T11:56:08.000Z</updated>
  <id>http://catlittlechen.com/</id>
  
  <author>
    <name><![CDATA[Chan Cat]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[记一次debug的坑]]></title>
    <link href="http://catlittlechen.com/2015/11/20/%E8%AE%B0%E4%B8%80%E6%AC%A1debug%E7%9A%84%E5%9D%91/"/>
    <id>http://catlittlechen.com/2015/11/20/记一次debug的坑/</id>
    <published>2015-11-20T03:57:00.000Z</published>
    <updated>2016-01-27T11:56:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u611F_u609F"><a href="#u611F_u609F" class="headerlink" title="感悟"></a>感悟</h2><p>这个故事告诉我们，永远不要相信自己的眼睛。</p>
<h2 id="u90A3_u5929"><a href="#u90A3_u5929" class="headerlink" title="那天"></a>那天</h2><p>天气晴朗，阳光明媚~<br>我用Go写了一段程序，程序中需要通过从文件中读取一段文字，然后拼入sql中，然后在数据库中执行。</p>
<p>由于我需要从文件中一行一行的读出数据，我用了这样子的方式读取。</p>
<pre><code>func readLines(path string) (lines []string, err error) {
    var (
            file   *os.File
            part   []byte
            prefix bool
    )

    if file, err = os.Open(path); err != nil {
            return
    }

    reader := bufio.NewReader(file)
    buffer := bytes.NewBuffer(make([]byte, 1024))

    for {
            if part, prefix, err = reader.ReadLine(); err != nil {
                    break
            }
            buffer.Write(part)
            if !prefix {
                    lines = append(lines, buffer.String())
                    buffer.Reset()
            }
    }
    if err == io.EOF {
            err = nil 
    }
    return
}
</code></pre><p>调用的时候，我通过用了大概如下的代码：</p>
<pre><code>lines， err := readLines(userFile)
if err != nil {
    return
}
for _, line := range lines {
    sqlStr := rawSql % line
    _, err = dbConn.Exec(sqlStr)
    if err != nil {
        return
    }
}
</code></pre><p>当然它报错了！这样子的错误信息~</p>
<pre><code>Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos; at line 1
</code></pre><p>通过查阅，我发现这个near ‘’，是的竟然是空的，不像一般的写错sql语句一样是会写明错误信息~<br>瞬间我就神经开始大条了。</p>
<pre><code>难道我后面写漏了什么？  
怎么可能！
不，我得先去喝杯水，然后再来看看。
水果到了，再吃个苹果。
吃完洗个手-。-
我觉得没错啊！
F**k
</code></pre><h2 id="u7ED3_u5C40"><a href="#u7ED3_u5C40" class="headerlink" title="结局"></a>结局</h2><p>不玩了，之所以我会认为自己没错，是因为我将整个sql语句打印了出来，在肉眼确认没错之后，又去mysql得命令行中直接执行了语句，结果十分顺利。<br>最后，十分大条的将从文件中读取出来的lines用长度打印了出来，瞬间我就斯巴达了！  </p>
<pre><code>for _, line := range lines {
    fmt.Printf(&quot;len[%s] is %d&quot;, line, len(line))
    sqlStr := rawSql % line
    fmt.Printf(&quot;sqlStr[%s] is %d&quot;, line, len(sqlStr))
}
</code></pre><p>结果。。。</p>
<pre><code>len[*****] is 1024!
sqlStr[*****] is 1065!
</code></pre><p>这就是为什么我执行失败的原因！sqlStr里面，存在着一段空白的buffer！却是打印不出来的~<br>最后我把代码改成了这样~</p>
<pre><code>data, err = ioutil.ReadAll(userFile)
if err != nil {
    return
}
lines := strings.Split(string(data), &quot;\n&quot;)
</code></pre><h2 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u611F_u609F"><a href="#u611F_u609F" class="headerlink" title="感悟"></a>感悟</h2><p>这个故事告诉我们，永远不要相信自己的眼睛。</p>
<h2 id="u90A3_u5929"><a hr]]>
    </summary>
    
      <category term="golang" scheme="http://catlittlechen.com/tags/golang/"/>
    
      <category term="踩坑日记" scheme="http://catlittlechen.com/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="golang" scheme="http://catlittlechen.com/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[仅仅]]></title>
    <link href="http://catlittlechen.com/2015/11/13/%E4%BB%85%E4%BB%85/"/>
    <id>http://catlittlechen.com/2015/11/13/仅仅/</id>
    <published>2015-11-13T13:12:01.000Z</published>
    <updated>2016-01-27T11:34:19.000Z</updated>
    <content type="html"><![CDATA[<p>独自一人<br>漫步入街头的咖啡厅<br>倚在窗边<br>约定的时刻已经过去<br>又该如何？<br>仅仅因为相信<br>仅仅等待五分钟。    </p>
<p>厅外<br>一辆小吃车<br>一个小女孩站在小凳子上<br>忙碌地为客人做着各式的小吃<br>人来人往<br>钱来食往！</p>
<p>厅内<br>静静地拿起手机<br>熟练地按下号码<br>猛然一惊！<br>却按下了断线<br>仅仅因为相信<br>仅仅等待五分钟。</p>
<p>厅外<br>开始下起小雨<br>小女孩吃力地撑起大篷伞<br>小雨淅沥<br>行人渐少<br>生意也冷清了许多<br>偶尔几个人匆忙而至<br>买了些许离去    </p>
<p>厅内<br>呆呆地看笑着<br>缓缓地按下字母键<br>写完了短信<br>却按了删除一键！<br>凝望着街头的拐角<br>仅仅因为相信<br>仅仅再等五分钟。</p>
<p>厅外<br>小雨渐大<br>环视四周<br>女孩只将车拉至屋檐下<br>为什么？<br>早市也该收了吧    </p>
<p>厅内<br>开始欺骗自己<br>一定会来的<br>站起来转身离开<br>走下台阶<br>第一眼望向街口<br>仅仅因为相信<br>仅仅这样离开<br>只希望自己来得太早太早。</p>
<p>屋檐下<br>那个女孩好像在发抖<br>为什么？<br>服务员说<br>那个欺骗小女孩的人<br>不可能回来的    </p>
<p>台阶下<br>呆呆地<br>她在等待那个人回来吗？<br>为什么就舍得骗她<br>双目开始颤抖<br>降温了<br>转身迈进        </p>
<p>屋檐下<br>女孩说，一定会来的！<br>猛然一怔<br>她笑了。    </p>
<p>屋檐下<br>钱被折成了小花<br>变戏法的送上<br>曾经练习了千遍<br>如今献给了另一个<br>转身离开<br>仅仅因为相信<br>仅仅这样离开</p>
<p>这算是believe<br>里面也隐藏着lie</p>
<p>街上<br>停伫回首<br>女孩朝着反方向离开<br>会吗？<br>仅仅因为相信<br>仅仅这样离开。        </p>
<p>街上<br>停伫<br>回首<br>女孩露出无邪的笑</p>
<p>街头<br>雨还在下<br>风却停了<br>一步步地迈向街头<br>那个身影<br>熟悉到陌生                </p>
<p>–你来啦！<br>–对不起，让你等那么久。。。<br>—-呀，你都湿透了！<br>–没事啦，走吧。<br>–什么？<br>–去吃小吃？<br>–好啊！        </p>
<p>仅仅因为相信。<br>雨在下。<br>天已晴。        </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>独自一人<br>漫步入街头的咖啡厅<br>倚在窗边<br>约定的时刻已经过去<br>又该如何？<br>仅仅因为相信<br>仅仅等待五分钟。    </p>
<p>厅外<br>一辆小吃车<br>一个小女孩站在小凳子上<br>忙碌地为客人做着各式的小吃<br>人来人往<br>钱]]>
    </summary>
    
      <category term="生活" scheme="http://catlittlechen.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="活着" scheme="http://catlittlechen.com/categories/%E6%B4%BB%E7%9D%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nagios和ganglia]]></title>
    <link href="http://catlittlechen.com/2015/11/11/nagios%E5%92%8Cganglia/"/>
    <id>http://catlittlechen.com/2015/11/11/nagios和ganglia/</id>
    <published>2015-11-11T08:32:19.000Z</published>
    <updated>2016-01-27T11:34:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8001_u751F_u5E38_u8C08_u2013_u76D1_u63A7"><a href="#u8001_u751F_u5E38_u8C08_u2013_u76D1_u63A7" class="headerlink" title="老生常谈–监控"></a>老生常谈–监控</h2><p>很远很久以前，看到过运维的同事在搞监控系统，自己这个苦逼的开发也在有空闲的时间里面，玩玩而已。  </p>
<p>服务器是用了腾讯云的，裸机~~，系统是ubuntu的。<br>参考了<a href="http://idevit.nl/node/93" target="_blank" rel="external">idevit</a></p>
<h2 id="INSTALL_NAGIOS"><a href="#INSTALL_NAGIOS" class="headerlink" title="INSTALL NAGIOS"></a>INSTALL NAGIOS</h2><p>这次的安装是源码安装，现在ubuntu的apt-get安装了nagios还是3版本的，所以还是多折腾，去下载源码咯。<br>先安装一些依赖的软件：</p>
<pre><code>apt-get install libperl-dev libpng12-dev libgd2-xpm-dev build-essential php5-gd wget nginx spwan-fcgi fcgiwrap php5-fpm 
</code></pre><p>本次的安装时4.1.1版本的。</p>
<pre><code>wget https://assets.nagios.com/downloads/nagioscore/releases/nagios-4.1.1.tar.gz
wget http://www.nagios-plugins.org/download/nagios-plugins-2.1.1.tar.gz
</code></pre><p>下载解压到服务器之中~</p>
<p>创建用户nagios和用户组nagcmd</p>
<pre><code>adduser --system --no-create-home --disabled-login --group nagios
groupadd nagcmd
usermod -G nagcmd nagios
usermod -a -G nagcmd www-data
</code></pre><p>配置nagios源码安装：</p>
<pre><code>cd nagios-4.1.1
./configure --prefix /usr/local/nagios --sysconfdir=/etc/nagios --with-command-user=nagios --with-command-group=nagcmd
#这里会检测所需的环境~
make all
make install
make install-init
make install-config
make install-commandmode
#这里是将开始编译，安装到指定目录，分发配置文件和配置了命令
</code></pre><p>安装完毕之后,这时候你可以把安装包里面的插件cp过来</p>
<pre><code>cp -rvf contrib/eventhandlers/ /usr/local/nagios/libexec/
chown -R nagios:nagios /usr/local/nagios/libexec/eventhandlers
</code></pre><p>nagios需要验证用户的权限，由于本次安装不想使用apache，选用了nginx，所以这次是通过以下的命令来生产用户验证的文件的。</p>
<pre><code>wget http://trac.edgewall.org/export/10791/trunk/contrib/htpasswd.py
chmod +x htpasswd.py
htpasswd.py -c -b /etc/nagios/htpasswd.users nagiosadmin password
</code></pre><p>这里的nagiosadmin是用户名，而password是密码，如果想要重新修改用户名的话，需要在/etc/nagios/cfg.cfg文件中加入权限。<br>比如用户名是catlittlechen的话，可以修改成下面这样子</p>
<pre><code>authorized_for_system_information=nagiosadmin,catlittlechen
</code></pre><p>安装下nagios官方提供的插件</p>
<pre><code>cd nagios-plugins-2.1.1
./configure --with-nagios-user=nagios --with-nagios-group=nagios
make
make install
</code></pre><p>之后可以通过执行下面的指令来验证下是否成功的配置了nagios</p>
<pre><code>/usr/local/nagios/bin/nagios -v /etc/nagios/nagio.cfg
</code></pre><p>启动的时候，这边的找了下，发现在/etc/rc.d/下，有一个nagios的脚本，就链接过来了/etc/init.d/nagios,然后就可以执行下面的命令启动来。</p>
<pre><code>service nagios start
</code></pre><p>弱弱的说，nginx配置在最下面~</p>
<h3 id="INSTALL_GANGLIA"><a href="#INSTALL_GANGLIA" class="headerlink" title="INSTALL GANGLIA"></a>INSTALL GANGLIA</h3><p>安装ganglia只是为了便捷的弥补下nagios只有定时检测的特性，当然，你可以尝试安装pnp4nagios来完成这个功能，但是ganglia更加的强大一些，而且真得简单啊。<br>命令：</p>
<pre><code>apt-get install -y ganglia-monitor rrdtool gmetad ganglia-webfrontend
</code></pre><p>这时候需要修改两个地方的配置文件</p>
<pre><code>vim /etc/ganglia/gmetad.conf
#data_source &quot;my cluster&quot; localhost
data_source &quot;cat chen&quot; localhost
vim /etc/ganglia/gmond.conf
cluster {
    #name = &quot;unspecified&quot;
    name = &quot;cat chen&quot;
    owner = &quot;unspecified&quot;
    latlong = &quot;unspecified&quot;
    url = &quot;unspecified&quot;
}
udp_send_channel  {
    #mcast_join = 239.2.11.71
    host = localhost
    port = 8649
    ttl = 1
}
udp_recv_channel {
    #mcast_join = 239.2.11.71
    port = 8649
    #bind = 239.2.11.71
}
</code></pre><p>然后执行下面的语句重启下服务</p>
<pre><code>service ganglia-monitor restart &amp;&amp; service gmetad restart
</code></pre><p>杠杠的，ganglia就这么搞定了~<br>这里为了习惯问题，我还执行了以下的命令</p>
<pre><code>cp -r /usr/share/ganglia-webfrontend/  /var/www/
mv /var/www/ganglia-webfrontend /var/www/ganglia
</code></pre><h3 id="Nagios__26amp_3B_26amp_3B_Ganglia"><a href="#Nagios__26amp_3B_26amp_3B_Ganglia" class="headerlink" title="Nagios &amp;&amp; Ganglia"></a>Nagios &amp;&amp; Ganglia</h3><p>最后，当然是配合ganglia和nagios了。</p>
<pre><code>git clone https://github.com/ganglia/monitor-core/
cp monitor-core/contrib/check_ganglia.py /usr/local/nagios/libexec
chown nagios:nagios check_ganglia.py
chmod +x check_ganglia.py
</code></pre><p>为了让nagios可以使用这个插件，需要在command配置中加入以下的配置</p>
<pre><code>vim /etc/nagios/objects/commands.cfg
define command {
    command_name check_ganglia
    command_line $USER1$/check_ganglia.py -h $HOSTNAME$ -m $ARG1$ -w $ARG2$ -c $ARG3$
}
</code></pre><p>然后就可以在配置项目里面配置相应的监控目标，比如我简答的配置如下</p>
<pre><code>vim /etc/nagios/objects/localhost.cfg
define service {
    use     local-service
    host_name       localhost
    service_description     Ganglia Bytes Out
    check_command   check_ganglia!bytes_out!80000!100000
}

define service {
    use     local-service
    host_name       localhost
    service_description     Ganglia Disk Free
    check_command   check_ganglia!disk_free!20!10
}
</code></pre><p>更加详细的配置，好书推荐，可以参考下<a href="http://nagios-cn.sourceforge.net/nagios-cn/configuration.html" target="_blank" rel="external">nagios_cn</a></p>
<h3 id="nginx_u914D_u7F6E_uFF1A"><a href="#nginx_u914D_u7F6E_uFF1A" class="headerlink" title="nginx配置："></a>nginx配置：</h3><pre><code>server {
    listen 10086
    server_name nagios.catlittlechen.com;
    access_log  /var/log/nginx/nagios.access.log;
    error_log   /var/log/nginx/nagios.error.log;

      auth_basic            &quot;Restricted Nagios Area!&quot;;
      auth_basic_user_file  /etc/nagios/htpasswd.users;

    root    /var/www;
    index   index.php index.html;

    location /nagios {
        index index.php;
        alias /usr/local/nagios/share/;
    }

    location /ganglia {
        index index.php index.html index.htm;
    }

    location ~ ^/nagios/(.*\.php)$ {
        alias /usr/local/nagios/share/$1;
        include /etc/nginx/fastcgi.conf;
        fastcgi_pass unix:/var/run/php5-fpm.sock;
    }

    location ~ \.cgi$ {
        root /usr/local/nagios/sbin/;
        rewrite ^/nagios/cgi-bin/(.*)\.cgi /$1.cgi break;
        fastcgi_param AUTH_USER $remote_user;
        fastcgi_param REMOTE_USER $remote_user;
        include /etc/nginx/fastcgi.conf;
        fastcgi_pass unix:/var/run/fcgiwrap.socket;
    }

    location ~ \.php$ {
        include /etc/nginx/fastcgi.conf;
        fastcgi_pass unix:/var/run/php5-fpm.sock;
    }

    location ~ /\.ht {
            deny all;
    }
}
</code></pre><p>晒图，别吐槽我的垃圾服务器</p>
<p><img src="http://7xnn4y.com1.z0.glb.clouddn.com/E73986A3-89CE-4BDF-8601-CC53F38C64ED.png" alt="ganglia"><br><img src="http://7xnn4y.com1.z0.glb.clouddn.com/76CE6A52-D7EC-42B8-90B5-C34B1D596421.png" alt="nagios"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8001_u751F_u5E38_u8C08_u2013_u76D1_u63A7"><a href="#u8001_u751F_u5E38_u8C08_u2013_u76D1_u63A7" class="headerlink" title="老生常谈–监控"><]]>
    </summary>
    
      <category term="ganglias" scheme="http://catlittlechen.com/tags/ganglias/"/>
    
      <category term="nagios" scheme="http://catlittlechen.com/tags/nagios/"/>
    
      <category term="监控" scheme="http://catlittlechen.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="折腾" scheme="http://catlittlechen.com/categories/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自建DNS服务器]]></title>
    <link href="http://catlittlechen.com/2015/10/19/%E8%87%AA%E5%BB%BADNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://catlittlechen.com/2015/10/19/自建DNS服务器/</id>
    <published>2015-10-19T11:41:33.000Z</published>
    <updated>2016-01-27T11:34:47.000Z</updated>
    <content type="html"><![CDATA[<p>今天有时间，我想看下自己建立DNS服务器，是怎么样的流程。<br>结果发现是如此的简单。</p>
<p>以下是基于ubuntu的。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名管理系统DNS(Domain Name System)，是通过域名来解析到IP的一种网络服务，自建DNS服务器，可以在内网中，自己设定特定的域名解析，达到内网机器可以无需配置host，达到访问内网服务的作用。</p>
<h3 id="DNS_u8BB0_u5F55_28_u5907_u5FD8_29_uFF1A"><a href="#DNS_u8BB0_u5F55_28_u5907_u5FD8_29_uFF1A" class="headerlink" title="DNS记录(备忘)："></a>DNS记录(备忘)：</h3><ul>
<li>A记录：        主机名或者域名 –&gt; 相应的IP地址；</li>
<li>NS记录：        记录域名有哪些DNS服务器来解析；</li>
<li>CNAME记录：    将域名的解析转到另外一个域名上去；</li>
<li>MX记录：        一个网络里面的电子邮件服务引导到特定服务器；</li>
<li>TXT记录：        提供了域名的文本信息；</li>
</ul>
<h2 id="Bind9"><a href="#Bind9" class="headerlink" title="Bind9"></a>Bind9</h2><p>bind(berkeley Internet Name Daemon)<br>建立DNS服务器，在ubuntu下只需要安装bind9就可以了。<br>    <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install bind9</span><br></pre></td></tr></table></figure></p>
<h3 id="u670D_u52A1_u5668"><a href="#u670D_u52A1_u5668" class="headerlink" title="服务器"></a>服务器</h3><p>bind9可以配置多种DNS服务器:</p>
<ol>
<li>缓冲服务器，用于缓存DNS服务，减少带宽使用；</li>
<li>主服务器，用于记录DNS服务信息；</li>
<li>从服务器，完整的备份主服务器的内容；</li>
<li>混合服务器，多种服务器合并的累心；</li>
<li>私用的主从服务器；</li>
</ol>
<h3 id="u4E3B_u8981_u914D_u7F6E"><a href="#u4E3B_u8981_u914D_u7F6E" class="headerlink" title="主要配置"></a>主要配置</h3><pre><code>cd /etc/bind/
</code></pre><p>可以看出在目录下面有多个name.conf*的文件，为配置文件；db.*的文件为DNS记录文件；*.keys文件是Bind在交互过程中用于检验的秘钥。    </p>
<h4 id="name-conf-options"><a href="#name-conf-options" class="headerlink" title="name.conf.options"></a>name.conf.options</h4><ul>
<li>forwarders: 选择现有的DNS提供商，以’;’分割，如果不写的话，这个地方会被默认为root名称服务器来解析，速度会特别慢；</li>
<li>directory “filename”: 用于存放该区域数据的文件；</li>
<li>forward first: 在尝试通过root服务器解析DNS请求先，对DNS请求进行转发(forward only 不进行转发)；</li>
<li>listen-on port *port{ ip-address;}: 指定监听哪一些网络接口(默认是127.0.0.1或者localhost)或者哪一个端口(默认是53)来监听客户端的查询；</li>
<li>listen-on-v6 *port{any;}: 指定Bind通过哪一个多端口去监听IPv6的客户端请求，any只可以被none代替；</li>
<li>query-source[-v6] address <em> port </em>: 服务器在查询解析的域名的时候，是有可能查询不到的而向其他服务器查询，因此，query-source可以设定这类查询采用什么样的地址和端口。这里的port只用于UDP的请求，TCP请求会随机使用一个大于1024的端口；</li>
<li>allow_query {ip-address;}: 指定说哪一些IP的网络可以进行普通的查询；</li>
<li>allow_transfer: 指定说哪一些IP的网络可以进行域的传输；</li>
<li>statistics-interval: 生成统计信息；设置为0，则不生成；</li>
<li>cleaning-interval: 缓存时间；</li>
<li>interface-interval: 定期检测网络接口中存在的接口，设置为0，则不扫描；</li>
<li>notify no: 在区域数据改动或者重启服务时，是否通知其他服务器；</li>
<li>dump-file “filename”: 执行rndc dumpdb时，存放的路径；</li>
</ul>
<h4 id="name-conf_logging"><a href="#name-conf_logging" class="headerlink" title="name.conf logging"></a>name.conf logging</h4><pre><code> logging {
       [ channel channel_name {
         ( file path_name
         [ versions ( number | unlimited ) ]
         [ size size_spec ]
         [ syslog (syslog_facility） | stderr | null)];
         [ severity (critical | error | warning | notice | info | debug [ level ] | dynamic ); ]
         [ print-category yes | no; ]
         [ print-severity yes | no; ]
         [ print-time yes | no; ]
       }; ]
       [ category category_name {
         channel_name ; [ channel_name ; ... ]
       }; ]
       ...
};
</code></pre><ul>
<li>file: 日志文件的路径；</li>
<li>versions, size: 用于控制日志文件的版本；<ol>
<li>如果size设置，versions没有设置，则写满日志文件之后，就会停止写入；</li>
<li>如果size，versions设置，则写满日志文件之后，会更新日志文件版本，继续写入；</li>
<li>如果size没设置，versions设置了，将会在Bind重启的时候再更新日志文件的版本；</li>
</ol>
</li>
<li>syslog, stderr, null: 三个参数填写出其中的一个，syslog会将输出的信息输出到系统日志中，详细的配置可以看下syslog，stderr将通道的输出信息重定向到标准错误流中，null则是忽略信息；</li>
<li>category: 这一部分的信息其实是将特定的输出内容写入指定的通道之中；具体有哪些种类的输出内容可以看下官方的介绍，种类太多也就不想列了。</li>
</ul>
<h4 id="name-conf_zone"><a href="#name-conf_zone" class="headerlink" title="name.conf zone"></a>name.conf zone</h4><p>在配置文件中，有name.conf.defaul-zones文件，已经默认的添加了部分DNS记录，而自建dns服务器，达到内网解析的关键，也就是配置这部分的文件。  </p>
<p>zone的配置模板目下所示：</p>
<pre><code>zone “catchenii.com” in {
    type master;
    file &quot;/etc/bind/db.catchenii.com&quot;
}
</code></pre><ul>
<li>type: 指DNS服务器的类型，分别为master(主服务器)，slave(从服务器)，hint(区域服务器)；</li>
<li>file: 区域数据文件；</li>
<li>master{server-ip-address}: 从服务器配置指定从哪个服务器中获取区域数据文件；</li>
<li>allow-update{!*;}: 是否允许外部创建DNS数据文件，默认是禁止的。(这一项就决定着有可能可以动态更新内网的DNS信息)  </li>
</ul>
<p>而对应的<strong>/etc/bind/db.catchenii.com</strong>区域数据文件则如图所示：<br><img src="http://7xnn4y.com1.z0.glb.clouddn.com/2.png" alt="db.catchenii.com"><br>区域文件有两种，一种是IP-&gt;域名，另外一种是域名-&gt;IP,上图当然是域名到IP得数据文件，两份记录的格式也是基本一致：</p>
<pre><code>&apos;.&apos;在区域文件中是由重要的含义的，如果域名没有在末尾加入&apos;.&apos;，则会追加域名在后面，完整的域名必须在末尾加&apos;.&apos;。
</code></pre><ul>
<li>$TTL: 默认的存活时间；</li>
<li>SOA: Start Of Authority 控制记录开始的位置。IN SOA后面是作为该区域的主服务器的名称。</li>
<li>Serial: 每修改一次文件，数字都会添加，用于告诉从服务器改变的通知；</li>
<li>Refresh: 下级服务器来校验serial number的时间间隔；</li>
<li>Retry: 下级服务器连接主服务器时出现错误的重试时间间隔；</li>
<li>Expire: 下级服务器无法联系主服务器时，缓存的超时时间；</li>
<li>Negative Cache TTL: 解析失败的记录的缓存时间；  </li>
</ul>
<p>接下来的数据为DNS的解析记录啦！</p>
<h3 id="u7ED3_u679C"><a href="#u7ED3_u679C" class="headerlink" title="结果"></a>结果</h3><p>修改好文件之后，可以重启下服务：</p>
<pre><code>sudo /etc/init.d/bind9 restart
</code></pre><p>效果如图所示：<br><img src="http://7xnn4y.com1.z0.glb.clouddn.com/3.png" alt="结果图"></p>
<p>嘻嘻。</p>
<h2 id="u5907_u8BB0_uFF1A"><a href="#u5907_u8BB0_uFF1A" class="headerlink" title="备记："></a>备记：</h2><p>各类DNS服务器的<a href="https://en.wikipedia.org/wiki/Comparison_of_DNS_server_software" target="_blank" rel="external">比较</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天有时间，我想看下自己建立DNS服务器，是怎么样的流程。<br>结果发现是如此的简单。</p>
<p>以下是基于ubuntu的。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS<]]>
    </summary>
    
      <category term="技术" scheme="http://catlittlechen.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="折腾" scheme="http://catlittlechen.com/categories/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[虚拟化技术了解]]></title>
    <link href="http://catlittlechen.com/2015/09/29/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/"/>
    <id>http://catlittlechen.com/2015/09/29/虚拟化技术了解/</id>
    <published>2015-09-29T12:05:17.000Z</published>
    <updated>2016-01-27T11:35:04.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u67D0_u4E00_u5929_uFF0Cdocker_u706B_u4E86_uFF01"><a href="#u67D0_u4E00_u5929_uFF0Cdocker_u706B_u4E86_uFF01" class="headerlink" title="某一天，docker火了！"></a>某一天，docker火了！</h4><p>相信第一个看了docker的人，当然，不是我这种菜鸟，都会很快的了解到docker所利用的技术和理论，其实早在多年之前，就已经被提出。</p>
<h3 id="LXC_3A"><a href="#LXC_3A" class="headerlink" title="LXC:"></a>LXC:</h3><p>lxc(Linux Containers)，是一种基于<strong>容器</strong>的操作系统层次的虚拟化技术，通过<strong>cgroup</strong>来控制硬件分配的，如CPU的使用率，内存的最大使用值等，通过<strong>namespace</strong>来隔离硬件环境。<br>这个点上推荐下陈皓先生的<a href="http://coolshell.cn/articles/17049.html" target="_blank" rel="external">文章</a>,通过了浅显易通的描述，可以帮读者更好的了解下docler及其运用的技术。</p>
<h3 id="KVM_uFF1A"><a href="#KVM_uFF1A" class="headerlink" title="KVM："></a>KVM：</h3><p>KVM(kernel-bases Virtual Machine),是基于Linux的<strong>hypervisor</strong>解决方案，也是首个被集成到Linux内核的hypervisor解决方案，并且是实现了完整的虚拟化的。新的操作系统会成为宿主操作系统的一个进程，通过/dev/kvm设备映射，拥有了自己的虚拟地址，因此，kvm是用了底层硬件的虚拟化支持来提供完整的虚拟化。</p>
<h2 id="SO_uFF1A"><a href="#SO_uFF1A" class="headerlink" title="SO："></a>SO：</h2><p>在虚拟化的性能方面，通过cgroup和namespace等技术的LXC会远超过KVM，但是虚拟化隔离方面，lxc只能说是达到了资源的控制和隔离，而不是真正意义上的硬件隔离，毕竟当你更新了宿主系统上面的一个关键程序的时候，lxc上的容器将很大程度上会收到影响，而kvm拥有完整的操作系统的虚拟化则不会受影响。<br>一切都是有代价的，取舍适当即可。<br>这里有一篇<a href="http://blog.chinaunix.net/uid-20662820-id-4514947.html" target="_blank" rel="external">文章</a>，博主通过测试数据，展示了LXC，KVM还有另外一种虚拟化技术XEN的性能数据。</p>
<p>目前，除了<a href="https://www.docker.com/" target="_blank" rel="external">Docker</a>外，目前国内还有另外一个值得关注的项目<a href="https://hyper.sh/" target="_blank" rel="external">hyper</a>,是基于hypervisor与docker的项目。</p>
<h3 id="TODO_3A"><a href="#TODO_3A" class="headerlink" title="TODO:"></a>TODO:</h3><p>了解下XEN，OVS，CEPH等，写写测试。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u67D0_u4E00_u5929_uFF0Cdocker_u706B_u4E86_uFF01"><a href="#u67D0_u4E00_u5929_uFF0Cdocker_u706B_u4E86_uFF01" class="headerlink" title]]>
    </summary>
    
      <category term="虚拟化" scheme="http://catlittlechen.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c的模板类]]></title>
    <link href="http://catlittlechen.com/2015/09/25/c%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB/"/>
    <id>http://catlittlechen.com/2015/09/25/c的模板类/</id>
    <published>2015-09-24T23:56:37.000Z</published>
    <updated>2016-01-27T11:33:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h2><p>昨天帮一个同学debug一个问题，想想也是醉了，太久没写C++，报错信息都看着陌生，还好有万能的<a href="https://www.google.com.hk/" target="_blank" rel="external">Google</a>，让我从<a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow</a>中找到了答案。</p>
<h2 id="u5F00_u59CB_u8BB2_u6545_u4E8B"><a href="#u5F00_u59CB_u8BB2_u6545_u4E8B" class="headerlink" title="开始讲故事"></a>开始讲故事</h2><p>C++标准库的书中，曾经说过这么一句话</p>
<pre><code>唯一一种方便的使用模板类的方法是用内联函数的方式在头文件中一次性实现。
</code></pre><h3 id="u4E3A_u4EC0_u4E48_u5462_uFF1F"><a href="#u4E3A_u4EC0_u4E48_u5462_uFF1F" class="headerlink" title="为什么呢？"></a>为什么呢？</h3><p>对于一个模板类，编译器在实例化的时候，通过模板类的参数，会创建一个新的类，举个例子：</p>
<pre><code>template&lt;typename T&gt;
struct Foo
{
  T bar;
  void doSomething(T param) {}
};

// somewhere in a .cpp
Foo&lt;int&gt; f; 
</code></pre><p>当编译器读到下面这一行的时候，就会创建一个新的类，我们可以把它叫做FooInt，这个类的实现等价于下面这种模式：</p>
<pre><code>struct FooInt
{
  int bar;
  void doSomething(int param) {}
}
</code></pre><p>因此，编译器开始需要去实现里面类的方法，自然是通过模板的参数来实现它们。如果这些实现不在头文件里面，编译器就无法获取到这些模板，自然就无法实现模板类的方法了。</p>
<hr>
<h3 id="u65B9_u6CD5_uFF1A"><a href="#u65B9_u6CD5_uFF1A" class="headerlink" title="方法："></a>方法：</h3><p>当然，将函数的声明和实现放在多个文件中，有时候是非常有必要的，简洁，条理，或者强迫症。。。<br>一种简单的解决方案是在头文件中声明类的方法之后，把类的实现写在文件B中，然后再头文件中include文件B，如下所示：</p>
<pre><code>// 在Foo.h中声明；
template &lt;typename T&gt;
struct Foo
{
  void doSomething(T param);
};
//include 实现的文件；
#include &quot;Foo.tpp&quot;

// 在Foo.tpp中实现函数；
template &lt;typename T&gt;
void Foo&lt;T&gt;::doSomething(T param)
{
    //implementation
}
</code></pre><p>哈哈，这是一种十分取巧的方法，不过也达到了目的，而且效果拔群。<br>还有一种方法，感觉上就不是很推荐了，但是更加正常一些。</p>
<pre><code>// Foo.h
// no implementation
template &lt;typename T&gt; struct Foo { ... };

// Foo.cpp
// implementation of Foo&apos;s methods
// explicit instantiations
template class Foo&lt;int&gt;;
template class Foo&lt;float&gt;;
</code></pre><p>这种方法就是在cpp文件中，实现的模板类的函数之后，在文件中同时将你想要使用的模板参数，明确的实例化出来。  </p>
<p>本人还是比较喜欢第一种，毕竟  </p>
<pre><code>1.我不喜欢一个模板类实现在一个文件里，过长的文件真得太受不了了。
2.第二种方法也就必须把所有的模板类函数实现在一个文件里！
</code></pre><p>博文翻译于<a href="http://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file" target="_blank" rel="external">stackoverflow</a>.</p>
<h4 id="TODO_uFF1A"><a href="#TODO_uFF1A" class="headerlink" title="TODO："></a>TODO：</h4><p>可以看下答主推荐的<a href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl" target="_blank" rel="external">文章</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h2><p>昨天帮一个同学debug一个问题，想想也是醉了，太久没写C++，报错信息都看着陌生，还好有万能的<a h]]>
    </summary>
    
      <category term="c" scheme="http://catlittlechen.com/tags/c/"/>
    
      <category term="踩坑日记" scheme="http://catlittlechen.com/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="c" scheme="http://catlittlechen.com/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]solr boolean operators]]></title>
    <link href="http://catlittlechen.com/2015/09/23/%E8%AF%91-solr-boolean-operators/"/>
    <id>http://catlittlechen.com/2015/09/23/译-solr-boolean-operators/</id>
    <published>2015-09-23T13:24:58.000Z</published>
    <updated>2016-01-27T11:35:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8E29_u5751_u611F_u8A00_uFF1A"><a href="#u8E29_u5751_u611F_u8A00_uFF1A" class="headerlink" title="踩坑感言："></a>踩坑感言：</h2><p>这个故事告诉我，<strong>做事情不要想当然</strong>，你觉得的事情，一定不是对的。</p>
<hr>
<h2 id="u8BD1_u6587_u539F_u6587_uFF1A"><a href="#u8BD1_u6587_u539F_u6587_uFF1A" class="headerlink" title="译文原文："></a>译文原文：</h2><p>来自于<a href="http://robotlibrarian.billdueber.com/2011/12/solr-and-boolean-operators/" target="_blank" rel="external">Bill Dueber</a>.</p>
<hr>
<h2 id="u7ED3_u8BBA_uFF1A"><a href="#u7ED3_u8BBA_uFF1A" class="headerlink" title="结论："></a>结论：</h2><p>在Solr中一定要用括号去管理优先级！！！</p>
<hr>
<h6 id="u641E_u8D77_u641E_u8D77_uFF01"><a href="#u641E_u8D77_u641E_u8D77_uFF01" class="headerlink" title="搞起搞起！"></a>搞起搞起！</h6><p>用过Solr的同学知道一下查询，Solr是怎么做的么？</p>
<pre><code>a OR b AND C
</code></pre><p>我可以给你三种选择，但是前两种肯定是错误的，而且你也不会想到第三种，因此还是不要花费太多的时间去想吧。</p>
<h3 id="boolean_u8FD0_u7B97_u7B26_u7684_u4F18_u5148_u7EA7"><a href="#boolean_u8FD0_u7B97_u7B26_u7684_u4F18_u5148_u7EA7" class="headerlink" title="boolean运算符的优先级"></a>boolean运算符的优先级</h3><p>如果你曾经知道过boolean运算相关的知识，你坑定为知道一个严格意义上的顺序，那就是NOT&gt;AND&gt;OR，因此，可能就会使下面一种执行顺序：</p>
<pre><code>a OR (b AND c)
</code></pre><p>这是猜想答案的一种，但是Solr不是这么做的。</p>
<h3 id="u4ECE_u5DE6_u5230_u53F3_uFF1F"><a href="#u4ECE_u5DE6_u5230_u53F3_uFF1F" class="headerlink" title="从左到右？"></a>从左到右？</h3><p>部分本地的学生，或者说也有至少一门编程语言，用的是简单的从左到右的执行方法，因此，就会有如下的一种执行顺序：</p>
<pre><code>（a OR b) AND c
</code></pre><p>不幸的是，这个还是错的。</p>
<h3 id="u90A3_u4E48_u8FD8_u6709_u4EC0_u4E48_u7B54_u6848_u5462_uFF1F"><a href="#u90A3_u4E48_u8FD8_u6709_u4EC0_u4E48_u7B54_u6848_u5462_uFF1F" class="headerlink" title="那么还有什么答案呢？"></a>那么还有什么答案呢？</h3><p>正确的执行顺序可以用如下的代码来表示，待会再通过lucene的查询分析来解释下：</p>
<pre><code>（b AND c）
</code></pre><p>在这里，第一个判断被抛弃了！也就是说，第一个判断其实是可有可无的！</p>
<h3 id="u4F60_u8FD8_u4F1A_u8BA9_u4F60_u7684_u4F7F_u7528_u8005_u5C06AND/OR/NOT_u653E_u5728_u4ED6_u4EEC_u7684_u67E5_u8BE2_u91CC_u4E48_uFF1F"><a href="#u4F60_u8FD8_u4F1A_u8BA9_u4F60_u7684_u4F7F_u7528_u8005_u5C06AND/OR/NOT_u653E_u5728_u4ED6_u4EEC_u7684_u67E5_u8BE2_u91CC_u4E48_uFF1F" class="headerlink" title="你还会让你的使用者将AND/OR/NOT放在他们的查询里么？"></a>你还会让你的使用者将AND/OR/NOT放在他们的查询里么？</h3><p>但愿他们并不知道什么是boolean运算；如果他们知道，但愿他们会使用括号，或者你可以帮他们判断出来，不然，他们将会死得很惨。。。。</p>
<h3 id="u66F4_u591A_u7684_u6D4B_u8BD5"><a href="#u66F4_u591A_u7684_u6D4B_u8BD5" class="headerlink" title="更多的测试"></a>更多的测试</h3><p>我在Solr(3.5)的里面测试下所有可以的情况（用的是curly，larry，moe和shemp的排序）总共有15种情况。</p>
<p>我写了个脚本来跑这些情况，分别在lucene和edismax下，看看可以得到什么样的结果。所有的测试中，lucene的默认运算符是AND，edismax的mm参数设置为100%</p>
<pre><code>Lucene                    EDismax
</code></pre><hr>
<ol>
<li>curly AND larry</li>
</ol>
<pre><code>curly larry               curly larry
curly larry moe           curly larry moe
curly larry shemp         curly larry shemp
curly larry moe shemp     curly larry moe shemp
</code></pre><ol>
<li>curly AND larry OR moe</li>
</ol>
<pre><code>curly                     curly larry
curly larry               curly larry moe
curly moe                 curly larry shemp
curly shemp               curly larry moe shemp
curly larry moe
curly larry shemp
curly moe shemp
curly larry moe shemp
</code></pre><ol>
<li>curly OR larry AND moe</li>
</ol>
<pre><code>larry moe                 larry moe
curly larry moe           curly larry moe
larry moe shemp           larry moe shemp
curly larry moe shemp     curly larry moe shemp
</code></pre><ol>
<li>curly AND larry OR moe AND shemp</li>
</ol>
<pre><code>curly moe shemp           curly larry moe shemp
curly larry moe shemp
</code></pre><ol>
<li>moe AND shemp OR curly AND larry</li>
</ol>
<pre><code>curly larry moe           curly larry moe shemp
curly larry moe shemp
</code></pre><p>查询1的答案是在预想中的。查询2的答案中，明显的就发现在lucene查询器下只有有’curly’就可以了，而在edismax下就需要’curly AND larry’（查询3一样的是变成了’larry AND moe’）。查询4和查询5也是同样的道理。当然，你可以看下debug查询输出，来知道她们是什么样的运行结果，但是没有告诉我为什么。</p>
<h3 id="u542F_u793A"><a href="#u542F_u793A" class="headerlink" title="启示"></a>启示</h3><p>好消息就是，不论是lucene还是edismax，在用括号的时候，她们的答案都是显而易见的。<br>在lucene-167cene的缺陷管理中也确实提到了这个问题(<a href="https://issues.apache.org/jira/browse/LUCENE-167" target="_blank" rel="external">Lucene-167</a>,<a href="https://issues.apache.org/jira/browse/LUCENE-1823" target="_blank" rel="external">lucene-1823</a>)，而在<a href="http://www.mail-archive.com/java-user@lucene.apache.org/msg00008.html" target="_blank" rel="external">2005 mailling list thread</a>中也指出也这种现象，但是它还是仍旧存在。</p>
<p>~~~</p>
<p>还是老老实实的用上括号吧，以免再入坑！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8E29_u5751_u611F_u8A00_uFF1A"><a href="#u8E29_u5751_u611F_u8A00_uFF1A" class="headerlink" title="踩坑感言："></a>踩坑感言：</h2><p>这个故事告诉我，<s]]>
    </summary>
    
      <category term="solr" scheme="http://catlittlechen.com/tags/solr/"/>
    
      <category term="翻译" scheme="http://catlittlechen.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="踩坑日记" scheme="http://catlittlechen.com/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="学习" scheme="http://catlittlechen.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <link href="http://catlittlechen.com/2015/09/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/"/>
    <id>http://catlittlechen.com/2015/09/22/第一篇博文/</id>
    <published>2015-09-22T13:24:52.000Z</published>
    <updated>2016-01-27T11:34:32.000Z</updated>
    <content type="html"><![CDATA[<p>你好，世界</p>
<hr>
<p>今天是拿到mac的第二天，兑现我的承诺，开始写属于自己的文字。</p>
<p>人类总是任性和懒惰，多么好的条件都不会造就一个人，也就是<strong>生于忧患，死于安乐</strong>吧。</p>
<p>好好奋斗，人生才刚刚开始。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>你好，世界</p>
<hr>
<p>今天是拿到mac的第二天，兑现我的承诺，开始写属于自己的文字。</p>
<p>人类总是任性和懒惰，多么好的条件都不会造就一个人，也就是<strong>生于忧患，死于安乐</strong>吧。</p>
<p>好好奋斗，人生才刚刚开始。</p]]>
    </summary>
    
      <category term="生活" scheme="http://catlittlechen.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="起点" scheme="http://catlittlechen.com/tags/%E8%B5%B7%E7%82%B9/"/>
    
      <category term="活着" scheme="http://catlittlechen.com/categories/%E6%B4%BB%E7%9D%80/"/>
    
  </entry>
  
</feed>
