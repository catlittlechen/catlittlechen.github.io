<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[c的模板类]]></title>
      <link href="http://catlittlechen.com/2015/09/25/c%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB/"/>
      <url>http://catlittlechen.com/2015/09/25/c%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="起因">起因</h2><p>昨天帮一个同学debug一个问题，想想也是醉了，太久没写C++，报错信息都看着陌生，还好有万能的<a href="https://www.google.com.hk/" target="_blank" rel="external">Google</a>，让我从<a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow</a>中找到了答案。</p>
<h2 id="开始讲故事">开始讲故事</h2><p>C++标准库的书中，曾经说过这么一句话</p>
<pre><code>唯一一种方便的使用模板类的方法是用内联函数的方式在头文件中一次性实现。
</code></pre><h3 id="为什么呢？">为什么呢？</h3><p>对于一个模板类，编译器在实例化的时候，通过模板类的参数，会创建一个新的类，举个例子：</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct</span> Foo
{
        T bar;
    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T param)</span> </span>{}
};

<span class="comment">// somewhere in a .cpp</span>
Foo&lt;<span class="keyword">int</span>&gt; f; 
</code></pre><p>当编译器读到下面这一行的时候，就会创建一个新的类，我们可以把它叫做FooInt，这个类的实现等价于下面这种模式：</p>
<pre><code><span class="keyword">struct</span> FooInt
{
       <span class="keyword">int</span> bar;
    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> param)</span> </span>{}
}
</code></pre><p>因此，编译器开始需要去实现里面类的方法，自然是通过模板的参数来实现它们。如果这些实现不在头文件里面，编译器就无法获取到这些模板，自然就无法实现模板类的方法了。</p>
<hr>
<h3 id="方法：">方法：</h3><p>当然，将函数的声明和实现放在多个文件中，有时候是非常有必要的，简洁，条理，或者强迫症。。。<br>一种简单的解决方案是在头文件中声明类的方法之后，把类的实现写在文件B中，然后再头文件中include文件B，如下所示：</p>
<pre><code><span class="comment">// 在Foo.h中声明；</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct</span> Foo
{
        <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T param)</span></span>;
};
<span class="comment">//include 实现的文件；</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Foo.tpp"</span></span>

<span class="comment">// 在Foo.tpp中实现函数；</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">void</span> Foo&lt;T&gt;::doSomething(T param)
{
    <span class="comment">//implementation</span>
}
</code></pre><p>哈哈，这是一种十分取巧的方法，不过也达到了目的，而且效果拔群。<br>还有一种方法，感觉上就不是很推荐了，但是更加正常一些。</p>
<pre><code><span class="comment">// Foo.h</span>
<span class="comment">// no implementation</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> Foo { ... };

<span class="comment">// Foo.cpp</span>
<span class="comment">// implementation of Foo's methods</span>
<span class="comment">// explicit instantiations</span>
<span class="keyword">template</span> <span class="keyword">class</span> Foo&lt;<span class="keyword">int</span>&gt;;
<span class="keyword">template</span> <span class="keyword">class</span> Foo&lt;<span class="keyword">float</span>&gt;;
</code></pre><p>这种方法就是在cpp文件中，实现的模板类的函数之后，在文件中同时将你想要使用的模板参数，明确的实例化出来。  </p>
<p>本人还是比较喜欢第一种，毕竟  </p>
<pre><code><span class="number">1.</span>我不喜欢一个模板类实现在一个文件里，过长的文件真得太受不了了。
<span class="number">2.</span>第二种方法也就必须把所有的模板类函数实现在一个文件里！
</code></pre><p>博文翻译于<a href="http://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file" target="_blank" rel="external">stackoverflow</a>.</p>
<h4 id="TODO：">TODO：</h4><p>可以看下答主推荐的<a href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl" target="_blank" rel="external">文章</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[译]solr boolean operators]]></title>
      <link href="http://catlittlechen.com/2015/09/23/%E8%AF%91-solr-boolean-operators/"/>
      <url>http://catlittlechen.com/2015/09/23/%E8%AF%91-solr-boolean-operators/</url>
      <content type="html"><![CDATA[<h2 id="踩坑感言：">踩坑感言：</h2><p>这个故事告诉我，<strong>做事情不要想当然</strong>，你觉得的事情，一定不是对的。</p>
<hr>
<h2 id="译文原文：">译文原文：</h2><p>来自于<a href="http://robotlibrarian.billdueber.com/2011/12/solr-and-boolean-operators/" target="_blank" rel="external">Bill Dueber</a>.</p>
<hr>
<h2 id="结论：">结论：</h2><p>在Solr中一定要用括号去管理优先级！！！</p>
<hr>
<p>######搞起搞起！<br>用过Solr的同学知道一下查询，Solr是怎么做的么？</p>
<pre><code><span class="tag">a</span> OR <span class="tag">b</span> AND C
</code></pre><p>我可以给你三种选择，但是前两种肯定是错误的，而且你也不会想到第三种，因此还是不要花费太多的时间去想吧。</p>
<h3 id="boolean运算符的优先级">boolean运算符的优先级</h3><p>如果你曾经知道过boolean运算相关的知识，你坑定为知道一个严格意义上的顺序，那就是NOT&gt;AND&gt;OR，因此，可能就会使下面一种执行顺序：</p>
<pre><code><span class="tag">a</span> OR (<span class="tag">b</span> AND c)
</code></pre><p>这是猜想答案的一种，但是Solr不是这么做的。</p>
<h3 id="从左到右？">从左到右？</h3><p>部分本地的学生，或者说也有至少一门编程语言，用的是简单的从左到右的执行方法，因此，就会有如下的一种执行顺序：</p>
<pre><code>（<span class="literal">a</span> <span class="literal">OR</span> b) <span class="literal">AND</span> c
</code></pre><p>不幸的是，这个还是错的。</p>
<h3 id="那么还有什么答案呢？">那么还有什么答案呢？</h3><p>正确的执行顺序可以用如下的代码来表示，待会再通过lucene的查询分析来解释下：</p>
<pre><code>（<span class="keyword">b </span><span class="keyword">AND </span>c）
</code></pre><p>在这里，第一个判断被抛弃了！也就是说，第一个判断其实是可有可无的！</p>
<p>###你还会让你的使用者将AND/OR/NOT放在他们的查询里么？<br>但愿他们并不知道什么是boolean运算；如果他们知道，但愿他们会使用括号，或者你可以帮他们判断出来，不然，他们将会死得很惨。。。。</p>
<p>###更多的测试<br>我在Solr(3.5)的里面测试下所有可以的情况（用的是curly，larry，moe和shemp的排序）总共有15种情况。</p>
<p>我写了个脚本来跑这些情况，分别在lucene和edismax下，看看可以得到什么样的结果。所有的测试中，lucene的默认运算符是AND，edismax的mm参数设置为100%</p>
<pre><code><span class="title">Lucene</span>                    EDismax
</code></pre><hr>
<ol>
<li>curly AND larry</li>
</ol>
<pre><code><span class="title">curly</span> larry               curly larry
curly larry moe           curly larry moe
curly larry shemp         curly larry shemp
curly larry moe shemp     curly larry moe shemp
</code></pre><ol>
<li>curly AND larry OR moe</li>
</ol>
<pre><code><span class="title">curly</span>                     curly larry
curly larry               curly larry moe
curly moe                 curly larry shemp
curly shemp               curly larry moe shemp
curly larry moe
curly larry shemp
curly moe shemp
curly larry moe shemp
</code></pre><ol>
<li>curly OR larry AND moe</li>
</ol>
<pre><code><span class="title">larry</span> moe                 larry moe
curly larry moe           curly larry moe
larry moe shemp           larry moe shemp
curly larry moe shemp     curly larry moe shemp
</code></pre><ol>
<li>curly AND larry OR moe AND shemp</li>
</ol>
<pre><code><span class="title">curly</span> moe shemp           curly larry moe shemp
curly larry moe shemp
</code></pre><ol>
<li>moe AND shemp OR curly AND larry</li>
</ol>
<pre><code><span class="title">curly</span> larry moe           curly larry moe shemp
curly larry moe shemp
</code></pre><p>查询1的答案是在预想中的。查询2的答案中，明显的就发现在lucene查询器下只有有’curly’就可以了，而在edismax下就需要’curly AND larry’（查询3一样的是变成了’larry AND moe’）。查询4和查询5也是同样的道理。当然，你可以看下debug查询输出，来知道她们是什么样的运行结果，但是没有告诉我为什么。</p>
<p>###启示<br>好消息就是，不论是lucene还是edismax，在用括号的时候，她们的答案都是显而易见的。<br>在lucene的缺陷管理中也确实提到了这个问题(<a href="https://issues.apache.org/jira/browse/LUCENE-167" target="_blank" rel="external">Lucene-167</a>,<a href="https://issues.apache.org/jira/browse/LUCENE-1823" target="_blank" rel="external">lucene-1823</a>)，而在<a href="http://www.mail-archive.com/java-user@lucene.apache.org/msg00008.html" target="_blank" rel="external">2005 mailling list thread</a>中也指出也这种现象，但是它还是仍旧存在。</p>
<p>~~~</p>
<p>还是老老实实的用上括号吧，以免再入坑！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第一篇博文]]></title>
      <link href="http://catlittlechen.com/2015/09/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/"/>
      <url>http://catlittlechen.com/2015/09/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</url>
      <content type="html"><![CDATA[<p>你好，世界</p>
<hr>
<p>今天是拿到mac的第二天，兑现我的承诺，开始写属于自己的文字。</p>
<p>人类总是任性和懒惰，多么好的条件都不会造就一个人，也就是<strong>生于忧患，死于安乐</strong>吧。</p>
<p>好好奋斗，人生才刚刚开始。</p>
]]></content>
    </entry>
    
  
  
</search>