<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CatChen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="互联网行业的猫">
<meta property="og:type" content="website">
<meta property="og:title" content="CatChen">
<meta property="og:url" content="http://catlittlechen.com/index.html">
<meta property="og:site_name" content="CatChen">
<meta property="og:description" content="互联网行业的猫">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CatChen">
<meta name="twitter:description" content="互联网行业的猫">
  
    <link rel="alternative" href="/atom.xml" title="CatChen" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CatChen</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我的王国，我一定会让你永垂不朽的</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">文章</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://catlittlechen.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-自建DNS服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/19/自建DNS服务器/" class="article-date">
  <time datetime="2015-10-19T11:41:33.000Z" itemprop="datePublished">2015-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/19/自建DNS服务器/">自建DNS服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天有时间，我想看下自己建立DNS服务器，是怎么样的流程。<br>结果发现是如此的简单。</p>
<p>以下是基于ubuntu的。</p>
<h2 id="DNS">DNS</h2><p>域名管理系统DNS(Domain Name System)，是通过域名来解析到IP的一种网络服务，自建DNS服务器，可以在内网中，自己设定特定的域名解析，达到内网机器可以无需配置host，达到访问内网服务的作用。</p>
<p>###DNS记录(备忘)：</p>
<ul>
<li>A记录：        主机名或者域名 –&gt; 相应的IP地址；</li>
<li>NS记录：        记录域名有哪些DNS服务器来解析；</li>
<li>CHAME记录：    将域名的解析转到另外一个域名上去；</li>
<li>MX记录：        一个网络里面的电子邮件服务引导到特定服务器；</li>
<li>TXT记录：        提供了域名的文本信息；</li>
</ul>
<h2 id="Bind9">Bind9</h2><p>bind(berkeley Internet Name Daemon)<br>建立DNS服务器，在ubuntu下只需要安装bind9就可以了。<br>    <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install bind9</span><br></pre></td></tr></table></figure></p>
<h3 id="服务器">服务器</h3><p>bind9可以配置多种DNS服务器:</p>
<ol>
<li>缓冲服务器，用于缓存DNS服务，减少带宽使用；</li>
<li>主服务器，用于记录DNS服务信息；</li>
<li>从服务器，完整的备份主服务器的内容；</li>
<li>混合服务器，多种服务器合并的累心；</li>
<li>私用的主从服务器；</li>
</ol>
<h3 id="主要配置">主要配置</h3><pre><code><span class="built_in">cd</span> /etc/<span class="built_in">bind</span>/
</code></pre><p>可以看出在目录下面有多个name.conf*的文件，为配置文件；db.*的文件为DNS记录文件；*.keys文件是Bind在交互过程中用于检验的秘钥。    </p>
<h4 id="name-conf-options">name.conf.options</h4><ul>
<li>forwarders: 选择现有的DNS提供商，以’;’分割，如果不写的话，这个地方会被默认为root名称服务器来解析，速度会特别慢；</li>
<li>directory “filename”: 用于存放该区域数据的文件；</li>
<li>forward first: 在尝试通过root服务器解析DNS请求先，对DNS请求进行转发(forward only 不进行转发)；</li>
<li>listen-on port *port{ ip-address;}: 指定监听哪一些网络接口(默认是127.0.0.1或者localhost)或者哪一个端口(默认是53)来监听客户端的查询；</li>
<li>listen-on-v6 *port{any;}: 指定Bind通过哪一个多端口去监听IPv6的客户端请求，any只可以被none代替；</li>
<li>query-source[-v6] address <em> port </em>: 服务器在查询解析的域名的时候，是有可能查询不到的而向其他服务器查询，因此，query-source可以设定这类查询采用什么样的地址和端口。这里的port只用于UDP的请求，TCP请求会随机使用一个大于1024的端口；</li>
<li>allow_query {ip-address;}: 指定说哪一些IP的网络可以进行普通的查询；</li>
<li>allow_transfer: 指定说哪一些IP的网络可以进行域的传输；</li>
<li>statistics-interval: 生成统计信息；设置为0，则不生成；</li>
<li>cleaning-interval: 缓存时间；</li>
<li>interface-interval: 定期检测网络接口中存在的接口，设置为0，则不扫描；</li>
<li>notify no: 在区域数据改动或者重启服务时，是否通知其他服务器；</li>
<li>dump-file “filename”: 执行rndc dumpdb时，存放的路径；</li>
</ul>
<h4 id="name-conf_logging">name.conf logging</h4><pre><code> <span class="tag">logging</span> {
       <span class="attr_selector">[ channel channel_name {
         ( file path_name
         [ versions ( number | unlimited ) ]</span>
         <span class="attr_selector">[ size size_spec ]</span>
         <span class="attr_selector">[ syslog (syslog_facility） | stderr | null)]</span>;
         <span class="attr_selector">[ severity (critical | error | warning | notice | info | debug [ level ]</span> | <span class="tag">dynamic</span> ); ]
         <span class="attr_selector">[ print-category yes | no; ]</span>
         <span class="attr_selector">[ print-severity yes | no; ]</span>
         <span class="attr_selector">[ print-time yes | no; ]</span>
       }; ]
       <span class="attr_selector">[ category category_name {
         channel_name ; [ channel_name ; ... ]</span>
       }; ]
       ...
};
</code></pre><ul>
<li>file: 日志文件的路径；</li>
<li>versions, size: 用于控制日志文件的版本；<ol>
<li>如果size设置，versions没有设置，则写满日志文件之后，就会停止写入；</li>
<li>如果size，versions设置，则写满日志文件之后，会更新日志文件版本，继续写入；</li>
<li>如果size没设置，versions设置了，将会在Bind重启的时候再更新日志文件的版本；</li>
</ol>
</li>
<li>syslog, stderr, null: 三个参数填写出其中的一个，syslog会将输出的信息输出到系统日志中，详细的配置可以看下syslog，stderr将通道的输出信息重定向到标准错误流中，null则是忽略信息；</li>
<li>category: 这一部分的信息其实是将特定的输出内容写入指定的通道之中；具体有哪些种类的输出内容可以看下官方的介绍，种类太多也就不想列了。</li>
</ul>
<h4 id="name-conf_zone">name.conf zone</h4><p>在配置文件中，有name.conf.defaul-zones文件，已经默认的添加了部分DNS记录，而自建dns服务器，达到内网解析的关键，也就是配置这部分的文件。  </p>
<p>zone的配置模板目下所示：</p>
<pre><code><span class="title">zone</span> “catchenii.com” <span class="keyword">in</span> {
    <span class="typedef"><span class="keyword">type</span> master;</span>
    file <span class="string">"/etc/bind/db.catchenii.com"</span>
}
</code></pre><ul>
<li>type: 指DNS服务器的类型，分别为master(主服务器)，slave(从服务器)，hint(区域服务器)；</li>
<li>file: 区域数据文件；</li>
<li>master{server-ip-address}: 从服务器配置指定从哪个服务器中获取区域数据文件；</li>
<li>allow-update{!*;}: 是否允许外部创建DNS数据文件，默认是禁止的。(这一项就决定着有可能可以动态更新内网的DNS信息)  </li>
</ul>
<p>而对应的<strong>/etc/bind/db.catchenii.com</strong>区域数据文件则如图所示：<br><img src="http://7xnn4y.com1.z0.glb.clouddn.com/2.png" alt="db.catchenii.com"><br>区域文件有两种，一种是IP-&gt;域名，另外一种是域名-&gt;IP,上图当然是域名到IP得数据文件，两份记录的格式也是基本一致：</p>
<pre><code><span class="variable">'.</span><span class="variable">'在区域文件中是由重要的含义的，如果域名没有在末尾加入</span><span class="variable">'.</span><span class="variable">'，则会追加域名在后面，完整的域名必须在末尾加</span><span class="variable">'.</span><span class="variable">'。</span>
</code></pre><ul>
<li>$TTL: 默认的存活时间；</li>
<li>SOA: Start Of Authority 控制记录开始的位置。IN SOA后面是作为该区域的主服务器的名称。</li>
<li>Serial: 每修改一次文件，数字都会添加，用于告诉从服务器改变的通知；</li>
<li>Refresh: 下级服务器来校验serial number的时间间隔；</li>
<li>Retry: 下级服务器连接主服务器时出现错误的重试时间间隔；</li>
<li>Expire: 下级服务器无法联系主服务器时，缓存的超时时间；</li>
<li>Negative Cache TTL: 解析失败的记录的缓存时间；  </li>
</ul>
<p>接下来的数据为DNS的解析记录啦！</p>
<h3 id="结果">结果</h3><p>修改好文件之后，可以重启下服务：</p>
<pre><code><span class="label">sudo</span> /etc/init.d/<span class="keyword">bind9 </span>restart
</code></pre><p>效果如图所示：<br><img src="http://7xnn4y.com1.z0.glb.clouddn.com/3.png" alt="结果图"></p>
<p>嘻嘻。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://catlittlechen.com/2015/10/19/自建DNS服务器/" data-id="cifz3fapl000bhvzkdkxkps6o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-虚拟化技术了解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/29/虚拟化技术了解/" class="article-date">
  <time datetime="2015-09-29T12:05:17.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/29/虚拟化技术了解/">虚拟化技术了解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="某一天，docker火了！">某一天，docker火了！</h4><p>相信第一个看了docker的人，当然，不是我这种菜鸟，都会很快的了解到docker所利用的技术和理论，其实早在多年之前，就已经被提出。</p>
<h3 id="LXC:">LXC:</h3><p>lxc(Linux Containers)，是一种基于<strong>容器</strong>的操作系统层次的虚拟化技术，通过<strong>cgroup</strong>来控制硬件分配的，如CPU的使用率，内存的最大使用值等，通过<strong>namespace</strong>来隔离硬件环境。<br>这个点上推荐下陈皓先生的<a href="http://coolshell.cn/articles/17049.html" target="_blank" rel="external">文章</a>,通过了浅显易通的描述，可以帮读者更好的了解下docler及其运用的技术。</p>
<h3 id="KVM：">KVM：</h3><p>KVM(kernel-bases Virtual Machine),是基于Linux的<strong>hypervisor</strong>解决方案，也是首个被集成到Linux内核的hypervisor解决方案，并且是实现了完整的虚拟化的。新的操作系统会成为宿主操作系统的一个进程，通过/dev/kvm设备映射，拥有了自己的虚拟地址，因此，kvm是用了底层硬件的虚拟化支持来提供完整的虚拟化。</p>
<h2 id="SO：">SO：</h2><p>在虚拟化的性能方面，通过cgroup和namespace等技术的LXC会远超过KVM，但是虚拟化隔离方面，lxc只能说是达到了资源的控制和隔离，而不是真正意义上的硬件隔离，毕竟当你更新了宿主系统上面的一个关键程序的时候，lxc上的容器将很大程度上会收到影响，而kvm拥有完整的操作系统的虚拟化则不会受影响。<br>一切都是有代价的，取舍适当即可。<br>这里有一篇<a href="http://blog.chinaunix.net/uid-20662820-id-4514947.html" target="_blank" rel="external">文章</a>，博主通过测试数据，展示了LXC，KVM还有另外一种虚拟化技术XEN的性能数据。</p>
<p>目前，除了<a href="https://www.docker.com/" target="_blank" rel="external">Docker</a>外，目前国内还有另外一个值得关注的项目<a href="https://hyper.sh/" target="_blank" rel="external">hyper</a>,是基于hypervisor与docker的项目。</p>
<h3 id="TODO:">TODO:</h3><p>了解下XEN，OVS，CEPH等，写写测试。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://catlittlechen.com/2015/09/29/虚拟化技术了解/" data-id="cifz3fapi0008hvzkdoh6p8ra" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟化/">虚拟化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-c的模板类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/25/c的模板类/" class="article-date">
  <time datetime="2015-09-24T23:56:37.000Z" itemprop="datePublished">2015-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/25/c的模板类/">c的模板类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="起因">起因</h2><p>昨天帮一个同学debug一个问题，想想也是醉了，太久没写C++，报错信息都看着陌生，还好有万能的<a href="https://www.google.com.hk/" target="_blank" rel="external">Google</a>，让我从<a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow</a>中找到了答案。</p>
<h2 id="开始讲故事">开始讲故事</h2><p>C++标准库的书中，曾经说过这么一句话</p>
<pre><code>唯一一种方便的使用模板类的方法是用内联函数的方式在头文件中一次性实现。
</code></pre><h3 id="为什么呢？">为什么呢？</h3><p>对于一个模板类，编译器在实例化的时候，通过模板类的参数，会创建一个新的类，举个例子：</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct</span> Foo
{
  T bar;
  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T param)</span> </span>{}
};

<span class="comment">// somewhere in a .cpp</span>
Foo&lt;<span class="keyword">int</span>&gt; f; 
</code></pre><p>当编译器读到下面这一行的时候，就会创建一个新的类，我们可以把它叫做FooInt，这个类的实现等价于下面这种模式：</p>
<pre><code><span class="keyword">struct</span> FooInt
{
  <span class="keyword">int</span> bar;
  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> param)</span> </span>{}
}
</code></pre><p>因此，编译器开始需要去实现里面类的方法，自然是通过模板的参数来实现它们。如果这些实现不在头文件里面，编译器就无法获取到这些模板，自然就无法实现模板类的方法了。</p>
<hr>
<h3 id="方法：">方法：</h3><p>当然，将函数的声明和实现放在多个文件中，有时候是非常有必要的，简洁，条理，或者强迫症。。。<br>一种简单的解决方案是在头文件中声明类的方法之后，把类的实现写在文件B中，然后再头文件中include文件B，如下所示：</p>
<pre><code><span class="comment">// 在Foo.h中声明；</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct</span> Foo
{
  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T param)</span></span>;
};
<span class="comment">//include 实现的文件；</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Foo.tpp"</span></span>

<span class="comment">// 在Foo.tpp中实现函数；</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">void</span> Foo&lt;T&gt;::doSomething(T param)
{
    <span class="comment">//implementation</span>
}
</code></pre><p>哈哈，这是一种十分取巧的方法，不过也达到了目的，而且效果拔群。<br>还有一种方法，感觉上就不是很推荐了，但是更加正常一些。</p>
<pre><code><span class="comment">// Foo.h</span>
<span class="comment">// no implementation</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> Foo { ... };

<span class="comment">// Foo.cpp</span>
<span class="comment">// implementation of Foo's methods</span>
<span class="comment">// explicit instantiations</span>
<span class="keyword">template</span> <span class="keyword">class</span> Foo&lt;<span class="keyword">int</span>&gt;;
<span class="keyword">template</span> <span class="keyword">class</span> Foo&lt;<span class="keyword">float</span>&gt;;
</code></pre><p>这种方法就是在cpp文件中，实现的模板类的函数之后，在文件中同时将你想要使用的模板参数，明确的实例化出来。  </p>
<p>本人还是比较喜欢第一种，毕竟  </p>
<pre><code><span class="number">1.</span>我不喜欢一个模板类实现在一个文件里，过长的文件真得太受不了了。
<span class="number">2.</span>第二种方法也就必须把所有的模板类函数实现在一个文件里！
</code></pre><p>博文翻译于<a href="http://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file" target="_blank" rel="external">stackoverflow</a>.</p>
<h4 id="TODO：">TODO：</h4><p>可以看下答主推荐的<a href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl" target="_blank" rel="external">文章</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://catlittlechen.com/2015/09/25/c的模板类/" data-id="cifz3fapq000jhvzkgwjdz6mz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/踩坑日记/">踩坑日记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="踩坑日记-译-solr-boolean-operators" class="article article-type-踩坑日记" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/23/译-solr-boolean-operators/" class="article-date">
  <time datetime="2015-09-23T13:24:58.000Z" itemprop="datePublished">2015-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/23/译-solr-boolean-operators/">[译]solr boolean operators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="踩坑感言：">踩坑感言：</h2><p>这个故事告诉我，<strong>做事情不要想当然</strong>，你觉得的事情，一定不是对的。</p>
<hr>
<h2 id="译文原文：">译文原文：</h2><p>来自于<a href="http://robotlibrarian.billdueber.com/2011/12/solr-and-boolean-operators/" target="_blank" rel="external">Bill Dueber</a>.</p>
<hr>
<h2 id="结论：">结论：</h2><p>在Solr中一定要用括号去管理优先级！！！</p>
<hr>
<p>######搞起搞起！<br>用过Solr的同学知道一下查询，Solr是怎么做的么？</p>
<pre><code><span class="tag">a</span> OR <span class="tag">b</span> AND C
</code></pre><p>我可以给你三种选择，但是前两种肯定是错误的，而且你也不会想到第三种，因此还是不要花费太多的时间去想吧。</p>
<h3 id="boolean运算符的优先级">boolean运算符的优先级</h3><p>如果你曾经知道过boolean运算相关的知识，你坑定为知道一个严格意义上的顺序，那就是NOT&gt;AND&gt;OR，因此，可能就会使下面一种执行顺序：</p>
<pre><code><span class="tag">a</span> OR (<span class="tag">b</span> AND c)
</code></pre><p>这是猜想答案的一种，但是Solr不是这么做的。</p>
<h3 id="从左到右？">从左到右？</h3><p>部分本地的学生，或者说也有至少一门编程语言，用的是简单的从左到右的执行方法，因此，就会有如下的一种执行顺序：</p>
<pre><code>（<span class="literal">a</span> <span class="literal">OR</span> b) <span class="literal">AND</span> c
</code></pre><p>不幸的是，这个还是错的。</p>
<h3 id="那么还有什么答案呢？">那么还有什么答案呢？</h3><p>正确的执行顺序可以用如下的代码来表示，待会再通过lucene的查询分析来解释下：</p>
<pre><code>（<span class="keyword">b </span><span class="keyword">AND </span>c）
</code></pre><p>在这里，第一个判断被抛弃了！也就是说，第一个判断其实是可有可无的！</p>
<p>###你还会让你的使用者将AND/OR/NOT放在他们的查询里么？<br>但愿他们并不知道什么是boolean运算；如果他们知道，但愿他们会使用括号，或者你可以帮他们判断出来，不然，他们将会死得很惨。。。。</p>
<p>###更多的测试<br>我在Solr(3.5)的里面测试下所有可以的情况（用的是curly，larry，moe和shemp的排序）总共有15种情况。</p>
<p>我写了个脚本来跑这些情况，分别在lucene和edismax下，看看可以得到什么样的结果。所有的测试中，lucene的默认运算符是AND，edismax的mm参数设置为100%</p>
<pre><code><span class="title">Lucene</span>                    EDismax
</code></pre><hr>
<ol>
<li>curly AND larry</li>
</ol>
<pre><code><span class="title">curly</span> larry               curly larry
curly larry moe           curly larry moe
curly larry shemp         curly larry shemp
curly larry moe shemp     curly larry moe shemp
</code></pre><ol>
<li>curly AND larry OR moe</li>
</ol>
<pre><code><span class="title">curly</span>                     curly larry
curly larry               curly larry moe
curly moe                 curly larry shemp
curly shemp               curly larry moe shemp
curly larry moe
curly larry shemp
curly moe shemp
curly larry moe shemp
</code></pre><ol>
<li>curly OR larry AND moe</li>
</ol>
<pre><code><span class="title">larry</span> moe                 larry moe
curly larry moe           curly larry moe
larry moe shemp           larry moe shemp
curly larry moe shemp     curly larry moe shemp
</code></pre><ol>
<li>curly AND larry OR moe AND shemp</li>
</ol>
<pre><code><span class="title">curly</span> moe shemp           curly larry moe shemp
curly larry moe shemp
</code></pre><ol>
<li>moe AND shemp OR curly AND larry</li>
</ol>
<pre><code><span class="title">curly</span> larry moe           curly larry moe shemp
curly larry moe shemp
</code></pre><p>查询1的答案是在预想中的。查询2的答案中，明显的就发现在lucene查询器下只有有’curly’就可以了，而在edismax下就需要’curly AND larry’（查询3一样的是变成了’larry AND moe’）。查询4和查询5也是同样的道理。当然，你可以看下debug查询输出，来知道她们是什么样的运行结果，但是没有告诉我为什么。</p>
<p>###启示<br>好消息就是，不论是lucene还是edismax，在用括号的时候，她们的答案都是显而易见的。<br>在lucene的缺陷管理中也确实提到了这个问题(<a href="https://issues.apache.org/jira/browse/LUCENE-167" target="_blank" rel="external">Lucene-167</a>,<a href="https://issues.apache.org/jira/browse/LUCENE-1823" target="_blank" rel="external">lucene-1823</a>)，而在<a href="http://www.mail-archive.com/java-user@lucene.apache.org/msg00008.html" target="_blank" rel="external">2005 mailling list thread</a>中也指出也这种现象，但是它还是仍旧存在。</p>
<p>~~~</p>
<p>还是老老实实的用上括号吧，以免再入坑！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://catlittlechen.com/2015/09/23/译-solr-boolean-operators/" data-id="cifz3fap80001hvzkippk1n3y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/solr/">solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/踩坑日记/">踩坑日记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="生活-第一篇博文" class="article article-type-生活" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/22/第一篇博文/" class="article-date">
  <time datetime="2015-09-22T13:24:52.000Z" itemprop="datePublished">2015-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/22/第一篇博文/">第一篇博文</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>你好，世界</p>
<hr>
<p>今天是拿到mac的第二天，兑现我的承诺，开始写属于自己的文字。</p>
<p>人类总是任性和懒惰，多么好的条件都不会造就一个人，也就是<strong>生于忧患，死于安乐</strong>吧。</p>
<p>好好奋斗，人生才刚刚开始。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://catlittlechen.com/2015/09/22/第一篇博文/" data-id="cifz3fapn000ehvzknl52gvc5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/起点/">起点</a></li></ul>

    </footer>
  </div>
  
</article>



  
  
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solr/">solr</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/起点/">起点</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/踩坑日记/">踩坑日记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">文章</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/10/19/自建DNS服务器/">自建DNS服务器</a>
          </li>
        
          <li>
            <a href="/2015/09/29/虚拟化技术了解/">虚拟化技术了解</a>
          </li>
        
          <li>
            <a href="/2015/09/25/c的模板类/">c的模板类</a>
          </li>
        
          <li>
            <a href="/2015/09/23/译-solr-boolean-operators/">[译]solr boolean operators</a>
          </li>
        
          <li>
            <a href="/2015/09/22/第一篇博文/">第一篇博文</a>
          </li>
        
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Chan Cat<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>