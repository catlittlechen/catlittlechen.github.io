{"tags":[{"name":"python","permalink":"https://catlittlechen.com/tags/python/","url":"/async/tags/python.json","count":2},{"name":"pyrobuf","permalink":"https://catlittlechen.com/tags/pyrobuf/","url":"/async/tags/pyrobuf.json","count":2}],"categories":[{"name":"python","permalink":"https://catlittlechen.com/categories/python/","url":"/async/categories/python.json","count":2}],"url":"/async/posts/2017/07/12/pyrobuf的改进.json","date":1499827338000,"path":{"year":2017,"month":7,"day":12,"name":"pyrobuf的改进"},"title":"pyrobuf的改进","permalink":"https://catlittlechen.com/2017/07/12/pyrobuf的改进/","content":"<h3 id=\"问题-1-–字符串编码\"><a href=\"#问题-1-–字符串编码\" class=\"headerlink\" title=\"问题(1)–字符串编码\"></a>问题(1)–字符串编码</h3><p>protobuf的标准里面，所有的字符串都是标准的UTF-8模式。而python恰恰是一个经常性遇到字符串编码问题的语言。</p>\n<p>但是pyrobuf里面，处理字符串的时候，当遇到字符串问题的时候，不会跑出错误，而会直接崩溃。</p>\n<h3 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决(1)\"></a>解决(1)</h3><p>源码的模板中，可以选择在字符串decode的判断中，加入try-except，pass掉错误。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">\tself._ = unicode(memory[current_offset:current_offset + field_size], <span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\">\tself._ = <span class=\"string\">u''</span></span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>当然，这种修改必须修改掉全部的decode判断。也有另外一种方式，就是简单地抛出错误。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cdef <span class=\"keyword\">int</span> _protobuf_deserialize(self, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *memory, <span class=\"keyword\">int</span> <span class=\"built_in\">size</span>) except <span class=\"number\">-1</span>:</span><br></pre></td></tr></table></figure>\n<p>在cython中<code>except -1</code>,代表着会将抛出的错误转化为python里面的Exception，就可以被上层调用的代码捕捉，不至于直接退出程序。</p>\n<h3 id=\"问题-2-–字段缺少\"><a href=\"#问题-2-–字段缺少\" class=\"headerlink\" title=\"问题(2)–字段缺少\"></a>问题(2)–字段缺少</h3><p>通过源码阅读，可以发现实际上如果protobuf里面的字段我并不需要，那么精简proto定义，可以减少解析的字段，因而优化解析的性能。然而，pyrobuf却判断了传入的data的长度，和解析过的长度，然后抛出了错误，</p>\n<h3 id=\"解决-2\"><a href=\"#解决-2\" class=\"headerlink\" title=\"解决(2)\"></a>解决(2)</h3><p>因而，需要删除这部分判断。<br><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> buf != <span class=\"keyword\">length</span>:</span><br><span class=\"line\">\traise DecodeError(<span class=\"string\">\"Truncated message: got %s expected %s\"</span> % (buf, size))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"另辟溪路\"><a href=\"#另辟溪路\" class=\"headerlink\" title=\"另辟溪路\"></a>另辟溪路</h2><p>google的protobuf库里面实际上已经有了protobufc，解析的效率实际上与pyrobuf差不多。如果单纯只是解析的话，可以直接使用google的原生库。当然，pyrobuf还提供了输出到json,dict的函数~~</p>\n"}