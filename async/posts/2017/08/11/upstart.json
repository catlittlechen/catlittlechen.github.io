{"tags":[{"name":"upstart","permalink":"http://catlittlechen.com/tags/upstart/","url":"/async/tags/upstart.json","count":1},{"name":"踩坑日记","permalink":"http://catlittlechen.com/tags/踩坑日记/","url":"/async/tags/踩坑日记.json","count":10}],"categories":[{"name":"upstart","permalink":"http://catlittlechen.com/categories/upstart/","url":"/async/categories/upstart.json","count":1}],"url":"/async/posts/2017/08/11/upstart.json","date":1502463835000,"path":{"year":2017,"month":8,"day":11,"name":"upstart"},"title":"踩坑日记之Upstart","permalink":"http://catlittlechen.com/2017/08/11/upstart/","content":"<h4 id=\"Upstart_u7684Expect\"><a href=\"#Upstart_u7684Expect\" class=\"headerlink\" title=\"Upstart的Expect\"></a>Upstart的Expect</h4><p>用upstart来管理系统的服务，很常见。但是也有需要注意的地方。比如，配置文件里面的expect。</p>\n<p>Expect有两种，”expect fork”表示进程只会fork一次，”expect daemonize”表示进程会fork两次，将自己变成后台进程。</p>\n<p>然而，错误的配置文件会让upstart启动某个进程之后，却无法跟踪管理这个进程的PID。结果Upstart会进入奇妙的状态。</p>\n<p>没办法，虽然本应该是它的PID，还没找到就不见了~因此，它十分怀念，念念不忘这个PID，以至于再也无法控制这个程序~无法启动，停止，重启这个进程。</p>\n<h3 id=\"u600E_u4E48_u529E_uFF1F\"><a href=\"#u600E_u4E48_u529E_uFF1F\" class=\"headerlink\" title=\"怎么办？\"></a>怎么办？</h3><p>方法其实很简单，如果我们可以启动一个服务，它的PID是Upstart所需要的PID，然后让Upstart跟踪到，然后kill掉这个PID的进程，那么Upstart的行为才可以变为正常。</p>\n<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><p>有一个ruby的<a href=\"https://raw.githubusercontent.com/ion1/workaround-upstart-snafu/master/workaround-upstart-snafu\" target=\"_blank\" rel=\"external\">代码</a>，可以参考下。亲测可用~</p>\n"}