{"tags":[{"name":"学习","permalink":"http://catlittlechen.com/tags/学习/","url":"/async/tags/学习.json","count":13},{"name":"naxsi","permalink":"http://catlittlechen.com/tags/naxsi/","url":"/async/tags/naxsi.json","count":1}],"categories":[{"name":"学习","permalink":"http://catlittlechen.com/categories/学习/","url":"/async/categories/学习.json","count":7}],"url":"/async/posts/2017/09/16/naxsi.json","date":1505566696000,"path":{"year":2017,"month":9,"day":16,"name":"naxsi"},"title":"naxsi","permalink":"http://catlittlechen.com/2017/09/16/naxsi/","content":"<h2 id=\"Naxsi\"><a href=\"#Naxsi\" class=\"headerlink\" title=\"Naxsi\"></a><a href=\"https://github.com/nbs-system/naxsi\" target=\"_blank\" rel=\"noopener\">Naxsi</a></h2><p>github上，NAXSI自我介绍是Nginx Anti XSS &amp; SQL Injection。顾名思义，他是nginx一个用来防止XSS和SQL注入的Nginx插件。</p>\n<p>原来就是将请求的各个参数，通过Naxsi预先设置的规则判断，通过得分，来决定是否拦截。</p>\n<h3 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h3><p>安装很简单，ubuntu上面只需要<code>apt-get nginx-naxsi</code>就可以啦~其他系统则可以选择官方介绍的，将Naxsi编译进nginx中，wiki上注明需要优先编译Naxsi。</p>\n<h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a>Configuration</h3><ol>\n<li>在http{}层，加入<code>include naxsi_core.rules</code>。naxsi_core.rules是naxsi自带的核心规则。可以防止一般的SQL注入和XSS。</li>\n<li>在server{}层，可以动态的设定一些参数。具体见<a href=\"https://github.com/nbs-system/naxsi/wiki/runtime-modifiers\" target=\"_blank\" rel=\"noopener\">传送门</a>。</li>\n<li>在location{}层，可以设置naxsi的开关(是否执行，学习模式[–&gt;观察者模式])，白名单，拦截规则，还有拦截后的重定向。依旧是一个[传送门] (<a href=\"https://github.com/nbs-system/naxsi/wiki/naxsi-setup)。\" target=\"_blank\" rel=\"noopener\">https://github.com/nbs-system/naxsi/wiki/naxsi-setup)。</a></li>\n</ol>\n<h3 id=\"具体细节\"><a href=\"#具体细节\" class=\"headerlink\" title=\"具体细节\"></a>具体细节</h3><p>LearningMode是学习模式，开启后，naxsi会在errorLog中打出拦截的请求和拦截的原因，但是并不会真正的拦截请求。因此，使用者可以通过errLog分析得到目前的拦截规则是否适用于服务。</p>\n<p>errLog大概长得像这样子</p>\n<pre><code>2017/09/15 06:12:33 [error] 18321#0: *291887486 NAXSI_FMT: ip=172.16.1.1&amp;server=a.b.com&amp;uri=/hello&amp;learning=1&amp;vers=0.55.3&amp;total_processed=10086&amp;total_blocked=404&amp;block=1&amp;cscore0=$SQL&amp;score0=8&amp;zone0=ARGS&amp;id0=1000&amp;var_name0=s&amp;zone1=ARGS&amp;id1=1009&amp;var_name1=s, client: 172.16.1.1, server: a.b.com, request: &quot;GET /hello?s=***** HTTP/1.1&quot;, host: &quot;a.b.com&quot;\n</code></pre><p>Naxsi认为，请求参数里面s中，有可能存在SQL注入(csore0=$SQL)，并且告诉我们，参与判定的规则是1000(id0=1000)，有问题的参数是s(var_name0=s)，当然出问题的不仅仅是一处时，他将会以平铺的模式，继续追加结果，如上所示。</p>\n<p>如果我们认为，这个参数是不存在问题的，可以自己加入白名单。<br>比如如果我们想要将s这个参数排除在检测之外，则可以加入如下规则：</p>\n<pre><code>BasicRule wl:0 &quot;mz:$ARGS_VAR:s|$URL:/hello&quot;;\n</code></pre><h2 id=\"Nxapi\"><a href=\"#Nxapi\" class=\"headerlink\" title=\"Nxapi\"></a>Nxapi</h2><p>对于大型网站而言，一旦开启了Naxsi，产生的errLog将会极其庞大。Naxsi提供一个方案，来做事件分析，生成相应的白名单。这就是<a href=\"https://github.com/nbs-system/naxsi/tree/master/nxapi\" target=\"_blank\" rel=\"noopener\">nxapi</a>啦。</p>\n"}