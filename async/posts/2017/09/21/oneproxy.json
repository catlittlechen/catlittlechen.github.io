{"tags":[{"name":"学习","permalink":"http://catlittlechen.com/tags/学习/","url":"/async/tags/学习.json","count":12},{"name":"oneproxy","permalink":"http://catlittlechen.com/tags/oneproxy/","url":"/async/tags/oneproxy.json","count":1}],"categories":[{"name":"学习","permalink":"http://catlittlechen.com/categories/学习/","url":"/async/categories/学习.json","count":6}],"url":"/async/posts/2017/09/21/oneproxy.json","date":1505954965000,"path":{"year":2017,"month":9,"day":21,"name":"oneproxy"},"title":"oneproxy","permalink":"http://catlittlechen.com/2017/09/21/oneproxy/","content":"<p>前段时间调研了一下oneproxy，google收录的资料比较少，基本都是看得官方的博客文章．<br><a href=\"http://www.onexsoft.com\" target=\"_blank\" rel=\"external\">oneproxy</a>，出生于阿里系的人员之手，主要的目的是为了解决数据库变迁所带来的问题．</p>\n<h2 id=\"u7279_u70B9\"><a href=\"#u7279_u70B9\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>负载均衡 + 分库分表 + 大数据 + SQL监控 + 安全审计</p>\n<p>说说我想了解的几个方面吧～</p>\n<h2 id=\"SQL_u76D1_u63A7\"><a href=\"#SQL_u76D1_u63A7\" class=\"headerlink\" title=\"SQL监控\"></a>SQL监控</h2><p>在解决安全方面，oneproxy有几个层次验证拦截．<br>  1．网络隔离，oneproxy可以限制其他机器对端口的访问</p>\n<ol>\n<li>登录验证，就是数据库用户密码验证</li>\n<li>访问限制，就是MySQL等常见的权限验证</li>\n<li>应用验证，类似于Google的动态口令，发送一个特殊的SQL语句来对数据库的访问进行解锁</li>\n<li>SQL白名单，需要搜集目前可以执行的SQL模板形成白名单，可以有效的防止SQL注入．<br>除此之外，还有基于客户端IP地址的流量控制，而且还有很多监控相关的数据可以查看，具体就不罗列了．</li>\n</ol>\n<h2 id=\"u8D1F_u8F7D_u5747_u8861\"><a href=\"#u8D1F_u8F7D_u5747_u8861\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>由于oneproxy实际上是一个代理，所以实际上，后端到底是访问哪个数据库，对于用户本身是未知的．<br>如同haproxy或者codis这一类应用一样，它可以减少实际数据库的链接数，减少tcp链接频繁创建．<br>所以，oneproxy不能用<code>use</code>,存储过程，<code>prepare</code>这一类的操作．<br>更大的好处是，多实例数据库可以防止单点故障．</p>\n<p>我看oneproxy有相关的配置，可以让它优先去访问master还是slave数据库，但是这个操作是oneproxy实例级别的，大部分业务场景都是读写分离，但是对于部分实时性要求比较高的场景，读写都会在主数据库完成，即使是开了SemiSync也是不够的，是否可以做到指定呢？还是说，这时候实际上，开发不应该基于MySQL等来完成实时的一致性校验．<br>目前的策略是 read_slave, read_balance, big_slave, big_balance．完整的介绍<a href=\"http://www.onexsoft.com/zh/oneproxy-read-traffic-scaleout.html\" target=\"_blank\" rel=\"external\">传送门</a></p>\n<h2 id=\"u5206_u5E93_u5206_u8868\"><a href=\"#u5206_u5E93_u5206_u8868\" class=\"headerlink\" title=\"分库分表\"></a>分库分表</h2><p>这是很多proxy都需要支持的一个特性，mysql实际上也是支持单实例的分区的，不过这对SQL解析和merge数据方存在一定的挑战．这个特性的基础上，大表可以根据需要分散到各个不同的数据库实例之中，对查询的性能瓶颈有很大的突破．不过存在的问题，比如分布式事务的支持，我看oneproxy还是没有解决的，毕竟老大难．<br>这里有个很不错的功能，是在分库分表的情况下，可以生成对应的主键．<a href=\"http://www.onexsoft.com/zh/oneproxy-sharding-key-sequence.html\" target=\"_blank\" rel=\"external\">创送们</a> 从前自己实现的分表里面，主键是通过redis来维护的自增值．用oneproxy的话，就方便多了～</p>\n"}