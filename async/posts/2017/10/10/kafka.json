{"tags":[{"name":"学习","permalink":"http://catlittlechen.com/tags/学习/","url":"/async/tags/学习.json","count":13},{"name":"kafka","permalink":"http://catlittlechen.com/tags/kafka/","url":"/async/tags/kafka.json","count":2}],"categories":[{"name":"kafka","permalink":"http://catlittlechen.com/categories/kafka/","url":"/async/categories/kafka.json","count":2}],"url":"/async/posts/2017/10/10/kafka.json","date":1507647293000,"path":{"year":2017,"month":10,"day":10,"name":"kafka"},"title":"kafka","permalink":"http://catlittlechen.com/2017/10/10/kafka/","content":"<h2 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h2><p>一大利器，以零拷贝，文件append之类好玩的优点，而被选择为了很多公司的数据总线，配置什么的就不多说了，Google等搜索引擎可以找到很多文章来介绍，那我就介绍下，我遇到的问题吧。</p>\n<h2 id=\"formatVersion\"><a href=\"#formatVersion\" class=\"headerlink\" title=\"formatVersion\"></a>formatVersion</h2><p>  kafka从0.8版本到现在，message的format有了3个版本，其中v1，v2的差距不大，但是v3的版本为了batch而生，因而版本差异比较大。<br>  但是落地到文件的版本，是由kafka启动的配置文件中配置的。kafka为了兼容各个版本，在通讯协议中支持message版本之间的转化。但是这个转化势必在server端执行，会浪费不必要的CPU，因为，在使用kafka的过程中，最好是根据业务需要，统一server与client的messageFormatVersion。</p>\n<h2 id=\"jmxtrans\"><a href=\"#jmxtrans\" class=\"headerlink\" title=\"jmxtrans\"></a>jmxtrans</h2><p>  kafka原生会暴露一个java系的监控接口，在kafka-server-start.sh中，可以看到JMX_PORT相关的配置。而jmxtrans是一个服务，可以将kafka—jmx中暴露出来的数据，整理写入ganglia中。配置可以看它的<a href=\"https://github.com/jmxtrans/jmxtrans\" target=\"_blank\" rel=\"noopener\">github</a>，kafka的监控项可以看<a href=\"http://kafka.apache.org/documentation/#configuration\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"kafka-manager\"><a href=\"#kafka-manager\" class=\"headerlink\" title=\"kafka-manager\"></a>kafka-manager</h2><p>  好吧，业务的同学都是喜欢有个页面的监控，所以嘛，找个yahoo的这个<a href=\"https://github.com/yahoo/kafka-manager\" target=\"_blank\" rel=\"noopener\">监控</a>.配置简单，可以通过jmx的接口，查找到类似于consumerGroup的延迟，数据传输的监控，并且可以看到类似于out of Sync等。点到为止~</p>\n<h2 id=\"replications\"><a href=\"#replications\" class=\"headerlink\" title=\"replications\"></a>replications</h2><p>  一个好的作品都是留给了使用者很多配置，很多很多配置。因此，kafka留了这个replication特性。如果你只关注性能，那么replication=1，每一个partition只有一份，这个在写入的时候，性能最佳，坏处就是单一个kafka实例失败的时候，这个partition就失败了。但是，一旦设置了replication&gt;1，那么kafka实例失败后，这个实例的partition只是outOfSync，重启等操作后，可以恢复。整个集群的partition还是可用的。</p>\n"}