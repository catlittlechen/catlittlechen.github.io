{"tags":[{"name":"学习","permalink":"http://catlittlechen.com/tags/学习/","url":"/async/tags/学习.json","count":12},{"name":"kafka","permalink":"http://catlittlechen.com/tags/kafka/","url":"/async/tags/kafka.json","count":2}],"categories":[{"name":"kafka","permalink":"http://catlittlechen.com/categories/kafka/","url":"/async/categories/kafka.json","count":2}],"url":"/async/posts/2017/10/25/kafka-replication.json","date":1508912583000,"path":{"year":2017,"month":10,"day":25,"name":"kafka-replication"},"title":"kafka-replication","permalink":"http://catlittlechen.com/2017/10/25/kafka-replication/","content":"<h2 id=\"u6587_u7AE0_u5206_u4EAB\"><a href=\"#u6587_u7AE0_u5206_u4EAB\" class=\"headerlink\" title=\"文章分享\"></a>文章分享</h2><p><a href=\"https://www.confluent.io/blog/how-to-choose-the-number-of-topicspartitions-in-a-kafka-cluster/\" target=\"_blank\" rel=\"external\">好文</a></p>\n<p>这里讲述了 partition 对于并发的重要性，其中介绍了 kafka 实现中，kafka 处理每一个 partition 都是对应一个线程的，所以多 partition 之间是写入是可以并发的。读取的时候，多个 consumer 消耗对应的 partition 是可以增加吞吐量的。</p>\n<p><a href=\"https://docs.confluent.io/current/kafka/deployment.html#hardware\" target=\"_blank\" rel=\"external\">好文</a><br>这里讲述了 kafka 对硬件的选择。</p>\n<h2 id=\"u6269_u5BB9\"><a href=\"#u6269_u5BB9\" class=\"headerlink\" title=\"扩容\"></a>扩容</h2><h3 id=\"add_broker\"><a href=\"#add_broker\" class=\"headerlink\" title=\"add broker\"></a>add broker</h3><p>kafka 加入一个 broker 只需要配置文件对了，直接起来就好了，没啥好说的。</p>\n<h3 id=\"add_partitions\"><a href=\"#add_partitions\" class=\"headerlink\" title=\"add partitions\"></a>add partitions</h3><p>增加 partition 的话，通过<code>kafka-topics.sh</code>这个脚本即可。</p>\n<pre><code>./kafka-topics.sh --alter --zookeeper 127.0.0.1:2181/kafka --partitions 10 --topic topic_test\n</code></pre><h4 id=\"u8C03_u6574_partitions\"><a href=\"#u8C03_u6574_partitions\" class=\"headerlink\" title=\"调整 partitions\"></a>调整 partitions</h4><p>调整的话，是通过<code>kafka-reassign-partitions.sh</code>这个脚本提交任务的。具体教程网上蛮多的，还是多写一些吧。</p>\n<h5 id=\"u6307_u5B9A_u9700_u8981_u8C03_u6574_u7684_topics\"><a href=\"#u6307_u5B9A_u9700_u8981_u8C03_u6574_u7684_topics\" class=\"headerlink\" title=\"指定需要调整的 topics\"></a>指定需要调整的 topics</h5><pre><code>{\n      &quot;topics&quot;: [\n        {&quot;topic&quot;:&quot;topic_test&quot;},\n      ],\n      &quot;version&quot;: 1\n}\nsave to test.json\n</code></pre><h5 id=\"u751F_u6210_u8C03_u6574_u540E_u7684_json\"><a href=\"#u751F_u6210_u8C03_u6574_u540E_u7684_json\" class=\"headerlink\" title=\"生成调整后的 json\"></a>生成调整后的 json</h5><pre><code>./kafka-reassign-partitions.sh --zookeeper 127.0.0.1:2181/kafka --topics-to-move-json-file ./test.json --broker-list &quot;0,1,2,3,4&quot; --generate\n</code></pre><p>这里的 broker-list 是 kafka 配置文件里面 broker-id 的集合。<br>命令之后，会生成两个 json，一个是目前 partition 的分布，第二个是调整后的 partiton 分布，这里保存为 move.json。这里 kafka 是按照自己的算法生成的，实际上，并不是最优。所以最好对照目前 partition 的分布，自己再做调整。<br>原则有两个，1. Skewed, partition 分布要均匀；2. Leader Skewed, leader 分布要均匀。</p>\n<h4 id=\"u63D0_u4EA4_u8C03_u6574_u7684_json\"><a href=\"#u63D0_u4EA4_u8C03_u6574_u7684_json\" class=\"headerlink\" title=\"提交调整的 json\"></a>提交调整的 json</h4><pre><code>./kafka-reassign-partitions.sh --zookeeper 127.0.0.1:2181/kafka --reassignment-json-file  move.json --execute\n</code></pre><p>提交的任务是异步执行的，这个过程中网络磁盘IO都会很大，负载也会升高，所以需要注意。</p>\n<h4 id=\"u68C0_u67E5\"><a href=\"#u68C0_u67E5\" class=\"headerlink\" title=\"检查\"></a>检查</h4><pre><code>./kafka-reassign-partitions.sh --zookeeper 127.0.0.1:2181/kafka --reassignment-json-file  move.json --verify\n</code></pre><h3 id=\"u6307_u5B9A_leader\"><a href=\"#u6307_u5B9A_leader\" class=\"headerlink\" title=\"指定 leader\"></a>指定 leader</h3><p>指定 leader 的话，通过<code>kafka-preferred-replica-election.sh</code>这个脚本提交的。默认是选择了 Replicas 中，还出于 sycn 状态的broker的第一个。所以上面提交调整的 json，需要把这一条考虑进去，注意 broker 的顺序。</p>\n<pre><code>./kafka-preferred-replica-election.sh --zookeeper 127.0.0.1:2181/kafka\n</code></pre>"}