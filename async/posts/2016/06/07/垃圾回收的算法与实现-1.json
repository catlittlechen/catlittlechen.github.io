{"tags":[{"name":"GC","permalink":"http://catlittlechen.com/tags/GC/","url":"/async/tags/GC.json","count":2}],"categories":[{"name":"读书笔记","permalink":"http://catlittlechen.com/categories/读书笔记/","url":"/async/categories/读书笔记.json","count":2}],"url":"/async/posts/2016/06/07/垃圾回收的算法与实现-1.json","date":1465302089000,"path":{"year":2016,"month":6,"day":7,"name":"垃圾回收的算法与实现-1"},"title":"垃圾回收的算法与实现(1)","permalink":"http://catlittlechen.com/2016/06/07/垃圾回收的算法与实现-1/","content":"<h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><h3 id=\"标记阶段\"><a href=\"#标记阶段\" class=\"headerlink\" title=\"标记阶段\"></a>标记阶段</h3><p>深度优先搜索 or 广度优先搜索，从 stack 上利遍历有对象，标记为1.<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def <span class=\"keyword\">make</span>(obj)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> obj.<span class=\"keyword\">mark</span> <span class=\"keyword\">is</span> False:</span><br><span class=\"line\">        obj.<span class=\"keyword\">mark</span> = True</span><br><span class=\"line\">        <span class=\"keyword\">for</span> child in obj.child<span class=\"variable\">s:</span></span><br><span class=\"line\">            <span class=\"keyword\">make</span>(child)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"清除阶段\"><a href=\"#清除阶段\" class=\"headerlink\" title=\"清除阶段\"></a>清除阶段</h3><p>里面堆内的所有对象，将标记为0的对象，全部回收到 freeList 中。<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def clear():<span class=\"type\"></span></span><br><span class=\"line\"><span class=\"type\">    newHeap </span>= []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> obj <span class=\"keyword\">in</span> heap:<span class=\"type\"></span></span><br><span class=\"line\"><span class=\"type\">        if obj</span>.mark is True</span><br><span class=\"line\">            <span class=\"keyword\">new</span><span class=\"type\">Heap</span>.append(obj)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:<span class=\"type\"></span></span><br><span class=\"line\"><span class=\"type\">            freeList</span>.append(obj)</span><br><span class=\"line\">    heap = <span class=\"keyword\">new</span><span class=\"type\">Heap</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"分配对象\"><a href=\"#分配对象\" class=\"headerlink\" title=\"分配对象\"></a>分配对象</h3><p>优先遍历 freeList,知道找到 obj.size 满足所需分配的内存，则返回。<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def malloc(<span class=\"built_in\">size</span>):</span><br><span class=\"line\">    <span class=\"built_in\">for</span> obj in freeList:</span><br><span class=\"line\">        <span class=\"built_in\">if</span> obj.<span class=\"built_in\">size</span> &gt; <span class=\"built_in\">size</span>:</span><br><span class=\"line\">            freeList.<span class=\"built_in\">remove</span>(obj)</span><br><span class=\"line\">            <span class=\"built_in\">return</span> obj</span><br><span class=\"line\">    <span class=\"built_in\">return</span> newObj(<span class=\"built_in\">size</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h3><ul>\n<li>实现简单</li>\n<li><code>碎片化</code>严重</li>\n<li>分配 <code>O(n)</code></li>\n<li>与<code>写时复制技术</code>不兼容</li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><ol>\n<li>多个 freeList<br> 将回收的对象根据<code>size</code>回到不同的 freeList 中，分配内存对象时，则可直接找到对象的 freeList。</li>\n<li>BiBOP<br> 将内存切分为固定的大小，如2个字节的，3个字节。<br> 每次分配 足够<code>满足 size 的 n 个连续块</code>。</li>\n<li>位图标记<br> 从 obj 中<code>分离标记</code>d，用其他数据结构管理。<br> 如：整数数组、树、散列表。</li>\n<li>延迟清除法<br> 4.1 只是标记，需要<code>分配时</code>才从堆中清除。<br> 4.2 清除一轮后，<code>重新标记清除</code>。<br> 4.3 还是没能从清除的对象中找到合适的，那就重新<code>系统分配</code>吧。</li>\n</ol>\n"}