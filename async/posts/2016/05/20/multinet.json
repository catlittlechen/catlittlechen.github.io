{"tags":[{"name":"golang","permalink":"http://catlittlechen.com/tags/golang/","url":"/async/tags/golang.json","count":3}],"categories":[{"name":"golang","permalink":"http://catlittlechen.com/categories/golang/","url":"/async/categories/golang.json","count":3}],"url":"/async/posts/2016/05/20/multinet.json","date":1463724442000,"path":{"year":2016,"month":5,"day":20,"name":"multinet"},"title":"multinet","permalink":"http://catlittlechen.com/2016/05/20/multinet/","content":"<h4 id=\"u8D77_u56E0\"><a href=\"#u8D77_u56E0\" class=\"headerlink\" title=\"起因\"></a>起因</h4><p>之前一段时间发现自己用go开发程序的过程中，大部分的时间都是用了标准的HTTP库，而没用到其他方式，比如单纯的TCP。在查看了go的标准库后，发现这个TCP库并没有想象中的好用，因此，我自己开始着手写一个好用点的。</p>\n<h4 id=\"u7ECF_u8FC7\"><a href=\"#u7ECF_u8FC7\" class=\"headerlink\" title=\"经过\"></a>经过</h4><p>在解决黏包的问题时，曾经尝试运用go标准库中的json库，将数据打包成为一个结构体的方式，确实时解决了黏包的问题，但是由于go的json库效率不高，整体的效率下下降了2-3倍。最后使用了最简单的模式，通过添加head的方式，达到得知传输的data的长度，进而解决了黏包的问题，而且效率上的影响可以忽略不计。</p>\n<p>在解决了黏包的问题之后，我也通过控制代理的模式，发现在高并发的情况下，也许服务端同时需要多次创建or关闭TCP连接，来达到通讯的目的。而实际TCP的使用中，或许大部分时间内，会有TCP连接处于空闲的阶段，那是否可以复用呢？</p>\n<p>因此，在multinet中，在一条TCP Connetion被创建的时候，调用库将同时创建n条连接，n为可配置参数。之后返回一个虚拟Conn供代码调用。在实际写入的过程中，conn在接收到调用者的写入之后，空闲的tcp连接会接受这个请求，将数据传给目标，而目标连接会根据读取的数据，分配给指定的虚拟Conn。</p>\n<p>在传输的过程中，TCP连接们，会在连接数过少，数据拥挤的时候，自动地创建新的连接来处理数据，当然，服务端也会反馈数据拥挤问题给客户端，让他创建新的连接。当然，这种方式还是比较简单粗暴的～～</p>\n<h3 id=\"u7ED3_u679C\"><a href=\"#u7ED3_u679C\" class=\"headerlink\" title=\"结果\"></a>结果</h3><p>一个写着玩的项目，multinet，目前放在了我的github上。地址见右上，在那个也许还没发现的地方。哈哈。</p>\n"}