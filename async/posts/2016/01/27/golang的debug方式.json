{"tags":[{"name":"golang","permalink":"http://catlittlechen.com/tags/golang/","url":"/async/tags/golang.json","count":2}],"categories":[{"name":"golang","permalink":"http://catlittlechen.com/categories/golang/","url":"/async/categories/golang.json","count":2}],"url":"/async/posts/2016/01/27/golang的debug方式.json","date":1453896663000,"path":{"year":2016,"month":1,"day":27,"name":"golang的debug方式"},"title":"golang的debug方式","permalink":"http://catlittlechen.com/2016/01/27/golang的debug方式/","content":"<h2 id=\"u534F_u7A0B\"><a href=\"#u534F_u7A0B\" class=\"headerlink\" title=\"协程\"></a>协程</h2><p>协程是轻量级的线程，在Go语言中对应着goroutine，由Go Runtime管理。由于Go在运行的过程中，如果多个goroutine在同时运行，当且仅当运行这个goroutine的线程被阻塞的时候，调度器也才会运行另外的goroutine。</p>\n<h3 id=\"u8FD9_u5C31_u610F_u5473_u7740\"><a href=\"#u8FD9_u5C31_u610F_u5473_u7740\" class=\"headerlink\" title=\"这就意味着\"></a>这就意味着</h3><pre><code>go func() {\n    for {\n    }\n}()\n</code></pre><p>这种函数被调用之后，这个goroutine会长期霸占着线程，而其它goroutine就只能饿死在内存中。<br>这种情况下，通过strace -f去跟踪系统调用的debug方式，是无法获取正确的信息。</p>\n<h3 id=\"kill_u5927_u6CD5\"><a href=\"#kill_u5927_u6CD5\" class=\"headerlink\" title=\"kill大法\"></a>kill大法</h3><p>Go程序在默认的信号处理中，如果收到了<em>SIGQUIT</em>的信号时，会将正在运行时的goroutine的调用栈输出。即：</p>\n<pre><code>kill -3 ***\n</code></pre><p>然后知道，自己是怎么坑自己的！</p>\n"}