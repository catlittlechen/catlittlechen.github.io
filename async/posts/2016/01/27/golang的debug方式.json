{"tags":[{"name":"golang","permalink":"https://catlittlechen.com/tags/golang/","url":"/async/tags/golang.json","count":3}],"categories":[{"name":"golang","permalink":"https://catlittlechen.com/categories/golang/","url":"/async/categories/golang.json","count":3}],"url":"/async/posts/2016/01/27/golang的debug方式.json","date":1453896663000,"path":{"year":2016,"month":1,"day":27,"name":"golang的debug方式"},"title":"golang的debug方式","permalink":"https://catlittlechen.com/2016/01/27/golang的debug方式/","content":"<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><p>协程是轻量级的线程，在Go语言中对应着goroutine，由Go Runtime管理。由于Go在运行的过程中，如果多个goroutine在同时运行，当且仅当运行这个goroutine的线程被阻塞的时候，调度器也才会运行另外的goroutine。</p>\n<h3 id=\"这就意味着\"><a href=\"#这就意味着\" class=\"headerlink\" title=\"这就意味着\"></a>这就意味着</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n<p>这种函数被调用之后，这个goroutine会长期霸占着线程，而其它goroutine就只能饿死在内存中。<br>这种情况下，通过strace -f去跟踪系统调用的debug方式，是无法获取正确的信息。</p>\n<h3 id=\"kill大法\"><a href=\"#kill大法\" class=\"headerlink\" title=\"kill大法\"></a>kill大法</h3><p>Go程序在默认的信号处理中，如果收到了<em>SIGQUIT</em>的信号时，会将正在运行时的goroutine的调用栈输出。即：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">kill</span> -3 ***</span><br></pre></td></tr></table></figure>\n<p>然后知道，自己是怎么坑自己的！</p>\n"}