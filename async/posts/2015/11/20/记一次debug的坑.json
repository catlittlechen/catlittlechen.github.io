{"tags":[{"name":"golang","permalink":"http://catlittlechen.com/tags/golang/","url":"/async/tags/golang.json","count":3},{"name":"踩坑日记","permalink":"http://catlittlechen.com/tags/踩坑日记/","url":"/async/tags/踩坑日记.json","count":3}],"categories":[{"name":"golang","permalink":"http://catlittlechen.com/categories/golang/","url":"/async/categories/golang.json","count":3}],"url":"/async/posts/2015/11/20/记一次debug的坑.json","date":1447991820000,"path":{"year":2015,"month":11,"day":20,"name":"记一次debug的坑"},"title":"记一次debug的坑","permalink":"http://catlittlechen.com/2015/11/20/记一次debug的坑/","content":"<h2 id=\"u611F_u609F\"><a href=\"#u611F_u609F\" class=\"headerlink\" title=\"感悟\"></a>感悟</h2><p>这个故事告诉我们，永远不要相信自己的眼睛。</p>\n<h2 id=\"u90A3_u5929\"><a href=\"#u90A3_u5929\" class=\"headerlink\" title=\"那天\"></a>那天</h2><p>天气晴朗，阳光明媚~<br>我用Go写了一段程序，程序中需要通过从文件中读取一段文字，然后拼入sql中，然后在数据库中执行。</p>\n<p>由于我需要从文件中一行一行的读出数据，我用了这样子的方式读取。</p>\n<pre><code>func readLines(path string) (lines []string, err error) {\n    var (\n            file   *os.File\n            part   []byte\n            prefix bool\n    )\n\n    if file, err = os.Open(path); err != nil {\n            return\n    }\n\n    reader := bufio.NewReader(file)\n    buffer := bytes.NewBuffer(make([]byte, 1024))\n\n    for {\n            if part, prefix, err = reader.ReadLine(); err != nil {\n                    break\n            }\n            buffer.Write(part)\n            if !prefix {\n                    lines = append(lines, buffer.String())\n                    buffer.Reset()\n            }\n    }\n    if err == io.EOF {\n            err = nil \n    }\n    return\n}\n</code></pre><p>调用的时候，我通过用了大概如下的代码：</p>\n<pre><code>lines， err := readLines(userFile)\nif err != nil {\n    return\n}\nfor _, line := range lines {\n    sqlStr := rawSql % line\n    _, err = dbConn.Exec(sqlStr)\n    if err != nil {\n        return\n    }\n}\n</code></pre><p>当然它报错了！这样子的错误信息~</p>\n<pre><code>Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos; at line 1\n</code></pre><p>通过查阅，我发现这个near ‘’，是的竟然是空的，不像一般的写错sql语句一样是会写明错误信息~<br>瞬间我就神经开始大条了。</p>\n<pre><code>难道我后面写漏了什么？  \n怎么可能！\n不，我得先去喝杯水，然后再来看看。\n水果到了，再吃个苹果。\n吃完洗个手-。-\n我觉得没错啊！\nF**k\n</code></pre><h2 id=\"u7ED3_u5C40\"><a href=\"#u7ED3_u5C40\" class=\"headerlink\" title=\"结局\"></a>结局</h2><p>不玩了，之所以我会认为自己没错，是因为我将整个sql语句打印了出来，在肉眼确认没错之后，又去mysql得命令行中直接执行了语句，结果十分顺利。<br>最后，十分大条的将从文件中读取出来的lines用长度打印了出来，瞬间我就斯巴达了！  </p>\n<pre><code>for _, line := range lines {\n    fmt.Printf(&quot;len[%s] is %d&quot;, line, len(line))\n    sqlStr := rawSql % line\n    fmt.Printf(&quot;sqlStr[%s] is %d&quot;, line, len(sqlStr))\n}\n</code></pre><p>结果。。。</p>\n<pre><code>len[*****] is 1024!\nsqlStr[*****] is 1065!\n</code></pre><p>这就是为什么我执行失败的原因！sqlStr里面，存在着一段空白的buffer！却是打印不出来的~<br>最后我把代码改成了这样~</p>\n<pre><code>data, err = ioutil.ReadAll(userFile)\nif err != nil {\n    return\n}\nlines := strings.Split(string(data), &quot;\\n&quot;)\n</code></pre><h2 id=\"Done\"><a href=\"#Done\" class=\"headerlink\" title=\"Done\"></a>Done</h2>"}